unit Win32.KSMedia;

(*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksmedia.h

Abstract:

    WDM-CSA Multimedia Definitions.

--*)

{ CMC.KSMedia and CMC.KS are not completed at the momenten, only as needed for CMC.MFAPI }

interface

uses
    Windows, CMC.KS;

{$Z4}
{$A4}

type
    TDEVPROPGUID = TGUID;
    PDEVPROPGUID = ^ TDEVPROPGUID;
    TDEVPROPID = ULONG;
    PDEVPROPID = ^TDEVPROPID;

    TDEVPROPKEY = record
        fmtid: TDEVPROPGUID;
        pid: TDEVPROPID;
    end;
    PDEVPROPKEY = ^TDEVPROPKEY;

const
    KSMEDIUMSETID_MidiBus: TGUID = '{05908040-3246-11D0-A5D6-28DB04C10000}';
    KSMEDIUMSETID_VPBus: TGUID = '{A18C15EC-CE43-11D0-ABE7-00A0C9223196}';
    KSINTERFACESETID_Media: TGUID = '{3A13EB40-30A7-11D0-A5D6-28DB04C10000}';
    // USB Component ID
    KSCOMPONENTID_USBAUDIO: TGUID = '{8F1275F0-26E9-4264-BA4D-39FFF01D94AA}';
    KSNODETYPE_INPUT_UNDEFINED: TGUID = '{DFF21BE0-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_MICROPHONE: TGUID = '{DFF21BE1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DESKTOP_MICROPHONE: TGUID = '{DFF21BE2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_PERSONAL_MICROPHONE: TGUID = '{DFF21BE3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE: TGUID = '{DFF21BE4-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_MICROPHONE_ARRAY: TGUID = '{DFF21BE5-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_PROCESSING_MICROPHONE_ARRAY: TGUID = '{DFF21BE6-F70F-11D0-B917-00A0C9223196}';
    KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR: TGUID = '{830a44f2-a32d-476b-be97-42845673b35a}';
    KSNODETYPE_OUTPUT_UNDEFINED: TGUID = '{DFF21CE0-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_SPEAKER: TGUID = '{DFF21CE1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_HEADPHONES: TGUID = '{DFF21CE2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO: TGUID = '{DFF21CE3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DESKTOP_SPEAKER: TGUID = '{DFF21CE4-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_ROOM_SPEAKER: TGUID = '{DFF21CE5-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_COMMUNICATION_SPEAKER: TGUID = '{DFF21CE6-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER: TGUID = '{DFF21CE7-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_BIDIRECTIONAL_UNDEFINED: TGUID = '{DFF21DE0-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_HANDSET: TGUID = '{DFF21DE1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_HEADSET: TGUID = '{DFF21DE2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION: TGUID = '{DFF21DE3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE: TGUID = '{DFF21DE4-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE: TGUID = '{DFF21DE5-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_TELEPHONY_UNDEFINED: TGUID = '{DFF21EE0-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_PHONE_LINE: TGUID = '{DFF21EE1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_TELEPHONE: TGUID = '{DFF21EE2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DOWN_LINE_PHONE: TGUID = '{DFF21EE3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_EXTERNAL_UNDEFINED: TGUID = '{DFF21FE0-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_ANALOG_CONNECTOR: TGUID = '{DFF21FE1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DIGITAL_AUDIO_INTERFACE: TGUID = '{DFF21FE2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_LINE_CONNECTOR: TGUID = '{DFF21FE3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_LEGACY_AUDIO_CONNECTOR: TGUID = '{DFF21FE4-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_SPDIF_INTERFACE: TGUID = '{DFF21FE5-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_1394_DA_STREAM: TGUID = '{DFF21FE6-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_1394_DV_STREAM_SOUNDTRACK: TGUID = '{DFF21FE7-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_EMBEDDED_UNDEFINED: TGUID = '{DFF220E0-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE: TGUID = '{DFF220E1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_EQUALIZATION_NOISE: TGUID = '{DFF220E2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_CD_PLAYER: TGUID = '{DFF220E3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE: TGUID = '{DFF220E4-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE: TGUID = '{DFF220E5-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_MINIDISK: TGUID = '{DFF220E6-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_ANALOG_TAPE: TGUID = '{DFF220E7-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_PHONOGRAPH: TGUID = '{DFF220E8-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VCR_AUDIO: TGUID = '{DFF220E9-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_DISC_AUDIO: TGUID = '{DFF220EA-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DVD_AUDIO: TGUID = '{DFF220EB-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_TV_TUNER_AUDIO: TGUID = '{DFF220EC-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_SATELLITE_RECEIVER_AUDIO: TGUID = '{DFF220ED-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_CABLE_TUNER_AUDIO: TGUID = '{DFF220EE-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_DSS_AUDIO: TGUID = '{DFF220EF-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_RADIO_RECEIVER: TGUID = '{DFF220F0-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_RADIO_TRANSMITTER: TGUID = '{DFF220F1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_MULTITRACK_RECORDER: TGUID = '{DFF220F2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_SYNTHESIZER: TGUID = '{DFF220F3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_HDMI_INTERFACE: TGUID = '{D1B9CC2A-F519-417f-91C9-55FA65481001}';
    KSNODETYPE_DISPLAYPORT_INTERFACE: TGUID = '{E47E4031-3EA6-418d-8F9B-B73843CCBA97}';
    KSNODETYPE_AUDIO_LOOPBACK: TGUID = '{8F42C0B2-91CE-4BCF-9CCD-0E599037AB35}';

    // {$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}
    KSNODETYPE_AUDIO_KEYWORDDETECTOR: TGUID = '{3817E0B8-DF58-4375-B669-C49634331F9D}';
    // {$ENDIF}

    // USB MIDI Nodes

    KSNODETYPE_MIDI_JACK: TGUID = '{265E0C3F-FA39-4df3-AB04-BE01B91E299A}';
    KSNODETYPE_MIDI_ELEMENT: TGUID = '{01C6FE66-6E48-4c65-AC9B-52DB5D656C7E}';


    // Hardware Audio Engine Node
    KSNODETYPE_AUDIO_ENGINE: TGUID = '{35CAF6E4-F3B3-4168-BB4B-55E77A461C7E}';

    // KS Node type for speakers node with static jack
    KSNODETYPE_SPEAKERS_STATIC_JACK: TGUID = '{28E04F87-4DBE-4f8d-8589-025D209DFB4A}';

    // GUID for Spdif Out pin name
    PINNAME_SPDIF_OUT: TGUID = '{3A264481-E52C-4b82-8E7A-C8E2F91DC380}';


    // GUID for Spdif In pin name

    PINNAME_SPDIF_IN: TGUID = '{15DC9025-22AD-41b3-8875-F4CEB0299E20}';


    // GUID for HDMI Out pin name
    PINNAME_HDMI_OUT: TGUID = '{387BFC03-E7EF-4901-86E0-35B7C32B00EF}';

    // GUID for Display Port Out pin name
    PINNAME_DISPLAYPORT_OUT: TGUID = '{21FBB329-1A4A-48da-A076-2318A3C59B26}';

    //{$if (NTDDI_VERSION < NTDDI_VISTA)}
    // Microsoft's WDMAUD virtual swsynth pin name guid
    KSNODETYPE_SWSYNTH: TGUID = '{423274A0-8B81-11D1-A050-0000F8004788}';
    // Microsoft's SWMIDI midi pin and node name guid
    KSNODETYPE_SWMIDI: TGUID = '{CB9BEFA0-A251-11D1-A050-0000F8004788}';
    //{$ENDIF}// (NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSNODETYPE_DRM_DESCRAMBLE: TGUID = '{FFBB6E3F-CCFE-4D84-90D9-421418B03A8E}';
    //{$ENDIF}// (NTDDI_VERSION >= NTDDI_WINXP)


    //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}


    // Nodetypes for Windows Phone Cellular Streaming.
    // {686D7CC0-D903-4258-B443-3A3D3580741C}
    KSNODETYPE_TELEPHONY_BIDI: TGUID = '{686D7CC0-D903-4258-B443-3A3D3580741C}';


    // Nodetype for FM Receiver.
    // {834A733C-F485-41C0-A62B-513025014E40}
    KSNODETYPE_FM_RX: TGUID = '{834A733C-F485-41C0-A62B-513025014E40}';
    //{$ENDIF}// (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

    // General categories
    KSCATEGORY_AUDIO: TGUID = '{6994AD04-93EF-11D0-A3CC-00A0C9223196}';
    KSCATEGORY_VIDEO: TGUID = '{6994AD05-93EF-11D0-A3CC-00A0C9223196}';

    //{$if (NTDDI_VERSION >= NTDDI_VISTA)}
    KSCATEGORY_REALTIME: TGUID = '{EB115FFC-10C8-4964-831D-6DCB02E6F23F}';
    //{$ENDIF}


    KSCATEGORY_TEXT: TGUID = '{6994AD06-93EF-11D0-A3CC-00A0C9223196}';
    KSCATEGORY_NETWORK: TGUID = '{67C9CC3C-69C4-11D2-8759-00A0C9223196}';
    KSCATEGORY_TOPOLOGY: TGUID = '{DDA54A40-1E4C-11D1-A050-405705C10000}';
    KSCATEGORY_VIRTUAL: TGUID = '{3503EAC4-1F26-11D1-8AB0-00A0C9223196}';
    KSCATEGORY_ACOUSTIC_ECHO_CANCEL: TGUID = '{BF963D80-C559-11D0-8A2B-00A0C9255AC1}';

    //{$if (NTDDI_VERSION < NTDDI_VISTA)}
    KSCATEGORY_SYSAUDIO: TGUID = '{A7C7A5B1-5AF3-11D1-9CED-00A024BF0407}';
    KSCATEGORY_WDMAUD: TGUID = '{3E227E76-690D-11D2-8161-0000F8775BF1}';
    //{$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)}
    KSCATEGORY_AUDIO_GFX: TGUID = '{9BAF9572-340C-11D3-ABDC-00A0C90AB16F}';
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)}
    KSCATEGORY_AUDIO_SPLITTER: TGUID = '{9EA331FA-B91B-45F8-9285-BD2BC77AFCDE}';
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

    KSCATEGORY_SYNTHESIZER: TGUID = '{DFF220F3-F70F-11D0-B917-00A0C9223196}';

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSCATEGORY_DRM_DESCRAMBLE: TGUID = '{FFBB6E3F-CCFE-4D84-90D9-421418B03A8E}';
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    //{$if (NTDDI_VERSION < NTDDI_VISTA)}
    KSCATEGORY_AUDIO_DEVICE: TGUID = '{FBF6F530-07B9-11D2-A71E-0000F8004788}';
    KSCATEGORY_PREFERRED_WAVEOUT_DEVICE: TGUID = '{D6C5066E-72C1-11D2-9755-0000F8004788}';
    KSCATEGORY_PREFERRED_WAVEIN_DEVICE: TGUID = '{D6C50671-72C1-11D2-9755-0000F8004788}';
    KSCATEGORY_PREFERRED_MIDIOUT_DEVICE: TGUID = '{D6C50674-72C1-11D2-9755-0000F8004788}';
    //{$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)

    // Special pin category for wdmaud
    KSCATEGORY_WDMAUD_USE_PIN_NAME: TGUID = '{47A4FA20-A251-11D1-A050-0000F8004788}';

    // Escalante Platform Interface
    KSCATEGORY_ESCALANTE_PLATFORM_DRIVER: TGUID = '{74f3aea8-9768-11d1-8e07-00a0c95ec22e}';

    // -- major types ---

    // 'vids' == MEDIATYPE_Video,
    KSDATAFORMAT_TYPE_VIDEO: TGUID = '{73646976-0000-0010-8000-00aa00389b71}';

    // 'auds' == MEDIATYPE_Audio
    KSDATAFORMAT_TYPE_AUDIO: TGUID = '{73647561-0000-0010-8000-00aa00389b71}';

    // 'txts' == MEDIATYPE_Text
    KSDATAFORMAT_TYPE_TEXT: TGUID = '{73747874-0000-0010-8000-00aa00389b71}';

    KSDATAFORMAT_SUBTYPE_WAVEFORMATEX: TGUID = '{00000000-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_ANALOG: TGUID = '{6dba3190-67bd-11cf-a0f7-0020afd156e4}';
    KSDATAFORMAT_SUBTYPE_PCM: TGUID = '{00000001-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEEE_FLOAT: TGUID = '{00000003-0000-0010-8000-00aa00389b71}';

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSDATAFORMAT_SUBTYPE_DRM: TGUID = '{00000009-0000-0010-8000-00aa00389b71}';
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)


    KSDATAFORMAT_SUBTYPE_ALAW: TGUID = '{00000006-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_MULAW: TGUID = '{00000007-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_ADPCM: TGUID = '{00000002-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_MPEG: TGUID = '{00000050-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SPECIFIER_VC_ID: TGUID = '{AD98D184-AAC3-11D0-A41C-00A0C9223196}';
    KSDATAFORMAT_SPECIFIER_WAVEFORMATEX: TGUID = '{05589f81-c356-11ce-bf01-00aa0055595a}';
    KSDATAFORMAT_SPECIFIER_DSOUND: TGUID = '{518590a2-a184-11d0-8522-00c04fd9baf3}';

    KSPROPSETID_DirectSound3DListener: TGUID = '{437b3414-d060-11d0-8583-00c04fd9baf3}';
    KSPROPSETID_DirectSound3DBuffer: TGUID = '{437b3411-d060-11d0-8583-00c04fd9baf3}';
    KSPROPSETID_Hrtf3d: TGUID = '{b66decb0-a083-11d0-851e-00c04fd9baf3}';
    KSPROPSETID_Itd3d: TGUID = '{6429f090-9fd9-11d0-a75b-00a0c90365e3}';
    KSDATAFORMAT_SUBTYPE_RIFF: TGUID = '{4995DAEE-9EE6-11D0-A40E-00A0C9223196}';
    KSDATAFORMAT_SUBTYPE_RIFFWAVE: TGUID = '{e436eb8b-524f-11ce-9f53-0020af0ba770}';
    KSPROPSETID_Bibliographic: TGUID = '{07BA150E-E2B1-11D0-AC17-00A0C9223196}';
    KSPROPSETID_TopologyNode: TGUID = '{45FFAAA1-6E1B-11D0-BCF2-444553540000}';
    KSPROPSETID_RtAudio: TGUID = '{A855A48C-2F78-4729-9051-1968746B9EEF}';
    KSPROPSETID_BtAudio: TGUID = '{7FA06C40-B8F6-4C7E-8556-E8C33A12E54D}';
    KSPROPSETID_DrmAudioStream: TGUID = '{2F2C8DDD-4198-4fac-BA29-61BB05B7DE06}';
    KSPROPSETID_SoundDetector: TGUID = '{113C425E-FD17-4057-B422-ED4074F1AFDF}';
    KSEVENTSETID_SoundDetector: TGUID = '{69785C9B-FC2D-49D6-AC32-4799F87DE9F6}';
    KSPROPSETID_Audio: TGUID = '{45FFAAA0-6E1B-11D0-BCF2-444553540000}';

    KSPROPSETID_TelephonyControl: TGUID = '{B6DF7EB1-D099-489F-A6A0-C0106F0887A7}';
    KSPROPSETID_TelephonyTopology: TGUID = '{ABF25C7E-0E64-4E32-B190-D0F6D7C53E97}';
    KSPROPSETID_FMRXTopology: TGUID = '{0C46CE8F-DC2D-4204-9DC9-F58963366563}';
    KSPROPSETID_FMRXControl: TGUID = '{947BBA3A-E8EE-4786-90C4-8428185F05BE}';
    KSEVENTSETID_Telephony: TGUID = '{B77F12B4-CEB4-4484-8D5E-52C1E7D8762D}';

    // Topology Node Type GUIDs
    KSNODETYPE_DAC: TGUID = '{507AE360-C554-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_ADC: TGUID = '{4D837FE0-C555-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_SRC: TGUID = '{9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_SUPERMIX: TGUID = '{E573ADC0-C555-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_MUX: TGUID = '{2CEAF780-C556-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_DEMUX: TGUID = '{C0EB67D4-E807-11D0-958A-00C04FB925D3}';
    KSNODETYPE_SUM: TGUID = '{DA441A60-C556-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_MUTE: TGUID = '{02B223C0-C557-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_VOLUME: TGUID = '{3A5ACC00-C557-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_TONE: TGUID = '{7607E580-C557-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_EQUALIZER: TGUID = '{9D41B4A0-C557-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_AGC: TGUID = '{E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}';
    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSNODETYPE_NOISE_SUPPRESS: TGUID = '{E07F903F-62FD-4e60-8CDD-DEA7236665B5}';
    // {$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    KSNODETYPE_DELAY: TGUID = '{144981E0-C558-11D0-8A2B-00A0C9255AC1}';

    KSNODETYPE_LOUDNESS: TGUID = '{41887440-C558-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_PROLOGIC_DECODER: TGUID = '{831C2C80-C558-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_STEREO_WIDE: TGUID = '{A9E69800-C558-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_REVERB: TGUID = '{EF0328E0-C558-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_CHORUS: TGUID = '{20173F20-C559-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_3D_EFFECTS: TGUID = '{55515860-C559-11D0-8A2B-00A0C9255AC1}';
    KSNODETYPE_PARAMETRIC_EQUALIZER: TGUID = '{19BB3A6A-CE2B-4442-87EC-6727C3CAB477}';
    KSNODETYPE_UPDOWN_MIX: TGUID = '{B7EDC5CF-7B63-4ee2-A100-29EE2CB6B2DE}';
    KSNODETYPE_DYN_RANGE_COMPRESSOR: TGUID = '{08C8A6A8-601F-4af8-8793-D905FF4CA97D}';

    KSNODETYPE_ACOUSTIC_ECHO_CANCEL: TGUID = '{BF963D80-C559-11D0-8A2B-00A0C9255AC1}';


    // {$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL: TGUID = '{1C22C56D-9879-4f5b-A389-27996DDC2810}';
    KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS: TGUID = '{5AB0882E-7274-4516-877D-4EEE99BA4FD0}';
    KSALGORITHMINSTANCE_SYSTEM_AGC: TGUID = '{950E55B9-877C-4c67-BE08-E47B5611130A}';
    KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR: TGUID = '{B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F}';
    KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR: TGUID = '{830a44f2-a32d-476b-be97-42845673b35a}';
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    KSNODETYPE_DEV_SPECIFIC: TGUID = '{941C7AC0-C559-11D0-8A2B-00A0C9255AC1}';

    {$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSNODETYPE_PROLOGIC_ENCODER: TGUID = '{8074C5B2-3C66-11D2-B45A-3078302C2030}';
    KSNODETYPE_SURROUND_ENCODER: TGUID = '{8074C5B2-3C66-11D2-B45A-3078302C2030}';
    KSNODETYPE_PEAKMETER: TGUID = '{A085651E-5F0D-4b36-A869-D195D6AB4B9E}';
    {$ENDIF}// (NTDDI_VERSION >= NTDDI_WINXP)

    {$if (NTDDI_VERSION < NTDDI_WINXP)}
    KSNODETYPE_SURROUND_ENCODER: TGUID = '{8074C5B2-3C66-11D2-B45A-3078302C2030}';
    {$ENDIF}// (NTDDI_VERSION < NTDDI_WINXP)

    //===========================================================================
    // Topology Node Name GUIDs for common audio nodes
    KSAUDFNAME_BASS: TGUID = '{185FEDE0-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_TREBLE: TGUID = '{185FEDE1-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIDRANGE: TGUID = '{A2CBE478-AE84-49A1-8B72-4AD09B78ED34}';
    KSAUDFNAME_3D_STEREO: TGUID = '{185FEDE2-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MASTER_VOLUME: TGUID = '{185FEDE3-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MASTER_MUTE: TGUID = '{185FEDE4-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_WAVE_VOLUME: TGUID = '{185FEDE5-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_WAVE_MUTE: TGUID = '{185FEDE6-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIDI_VOLUME: TGUID = '{185FEDE7-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIDI_MUTE: TGUID = '{185FEDE8-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_CD_VOLUME: TGUID = '{185FEDE9-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_CD_MUTE: TGUID = '{185FEDEA-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_LINE_VOLUME: TGUID = '{185FEDEB-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_LINE_MUTE: TGUID = '{185FEDEC-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIC_VOLUME: TGUID = '{185FEDED-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIC_MUTE: TGUID = '{185FEDEE-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_RECORDING_SOURCE: TGUID = '{185FEDEF-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_PC_SPEAKER_VOLUME: TGUID = '{185FEDF0-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_PC_SPEAKER_MUTE: TGUID = '{185FEDF1-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIDI_IN_VOLUME: TGUID = '{185FEDF2-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_CD_IN_VOLUME: TGUID = '{185FEDF3-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_LINE_IN_VOLUME: TGUID = '{185FEDF4-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIC_IN_VOLUME: TGUID = '{185FEDF5-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_WAVE_IN_VOLUME: TGUID = '{185FEDF6-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_VOLUME_CONTROL: TGUID = '{185FEDF7-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MIDI: TGUID = '{185FEDF8-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_LINE_IN: TGUID = '{185FEDF9-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_RECORDING_CONTROL: TGUID = '{185FEDFA-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_CD_AUDIO: TGUID = '{185FEDFB-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_AUX_VOLUME: TGUID = '{185FEDFC-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_AUX_MUTE: TGUID = '{185FEDFD-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_AUX: TGUID = '{185FEDFE-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_PC_SPEAKER: TGUID = '{185FEDFF-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_WAVE_OUT_MIX: TGUID = '{185FEE00-9905-11D1-95A9-00C04FB925D3}';
    KSAUDFNAME_MONO_OUT: TGUID = '{F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_STEREO_MIX: TGUID = '{00DFF077-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_MONO_MIX: TGUID = '{00DFF078-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_MONO_OUT_VOLUME: TGUID = '{1AD247EB-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_MONO_OUT_MUTE: TGUID = '{1AD247EC-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_STEREO_MIX_VOLUME: TGUID = '{1AD247ED-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_STEREO_MIX_MUTE: TGUID = '{22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_MONO_MIX_VOLUME: TGUID = '{22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_MONO_MIX_MUTE: TGUID = '{2BC31D69-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_MICROPHONE_BOOST: TGUID = '{2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_ALTERNATE_MICROPHONE: TGUID = '{2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68}';
    KSAUDFNAME_3D_DEPTH: TGUID = '{63FF5747-991F-11d2-AC4D-00C04F8EFB68}';
    KSAUDFNAME_3D_CENTER: TGUID = '{9F0670B4-991F-11d2-AC4D-00C04F8EFB68}';
    KSAUDFNAME_VIDEO_VOLUME: TGUID = '{9B46E708-992A-11d2-AC4D-00C04F8EFB68}';
    KSAUDFNAME_VIDEO_MUTE: TGUID = '{9B46E709-992A-11d2-AC4D-00C04F8EFB68}';
    KSAUDFNAME_VIDEO: TGUID = '{915DAEC4-A434-11d2-AC52-00C04F8EFB68}';


    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSAUDFNAME_PEAKMETER: TGUID = '{57E24340-FC5B-4612-A562-72B11A29DFAE}';
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)


    KSMETHODSETID_Wavetable: TGUID = '{DCEF31EB-D907-11D0-9583-00C04FB925D3}';

    // {$if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)}
    KSPROPSETID_Acoustic_Echo_Cancel: TGUID = '{D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2}';
    // {$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION < NTDDI_WS03)
    KSPROPSETID_Wave_Queued: TGUID = '{16a15b10-16f0-11d0-a195-0020afd156e4}';
    KSMETHODSETID_Wave_Queued: TGUID = '{7432c160-8827-11cf-a102-0020afd156e4}';
    //{$ENDIF} // (NTDDI_VERSION < NTDDI_WS03)

    KSPROPSETID_Wave: TGUID = '{924e54b0-630f-11cf-ada7-08003e30494a}';

    KSMUSIC_TECHNOLOGY_PORT: TGUID = '{86C92E60-62E8-11CF-A5D6-28DB04C10000}';
    KSMUSIC_TECHNOLOGY_SQSYNTH: TGUID = '{0ECF4380-62E9-11CF-A5D6-28DB04C10000}';
    KSMUSIC_TECHNOLOGY_FMSYNTH: TGUID = '{252C5C80-62E9-11CF-A5D6-28DB04C10000}';
    KSMUSIC_TECHNOLOGY_WAVETABLE: TGUID = '{394EC7C0-62E9-11CF-A5D6-28DB04C10000}';
    KSMUSIC_TECHNOLOGY_SWSYNTH: TGUID = '{37407736-3620-11D1-85D3-0000F8754380}';

    // {$if (NTDDI_VERSION < NTDDI_WS03)}
    KSPROPSETID_WaveTable: TGUID = '{8539E660-62E9-11CF-A5D6-28DB04C10000}';
    KSEVENTSETID_Cyclic: TGUID = '{142C1AC0-072A-11D0-A5D6-28DB04C10000}';
    // {$ENDIF} // (NTDDI_VERSION < NTDDI_WS03)

    KSPROPSETID_Cyclic: TGUID = '{3FFEAEA0-2BEE-11CF-A5D6-28DB04C10000}';
    KSEVENTSETID_AudioControlChange: TGUID = '{E85E9698-FA2F-11D1-95BD-00C04FB925D3}';
    KSEVENTSETID_LoopedStreaming: TGUID = '{4682B940-C6EF-11D0-96D8-00AA0051E51D}';

    //  {$if (NTDDI_VERSION <= NTDDI_WINXP)}
    KSEVENTSETID_Sysaudio: TGUID = '{04800320-4491-11D1-A050-405705C10000}';
    // {$ENDIF} // (NTDDI_VERSION <= NTDDI_WINXP)

    // {$if (NTDDI_VERSION < NTDDI_VISTA)}
    KSPROPSETID_Sysaudio: TGUID = '{CBE3FAA0-CC75-11D0-B465-00001A1818E6}';
    // {$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION < NTDDI_VISTA)}
    KSPROPSETID_Sysaudio_Pin: TGUID = '{A3A53220-C6E4-11D0-B465-00001A1818E6}';
    // {$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)

    KSPROPSETID_AudioGfx: TGUID = '{79A9312E-59AE-43b0-A350-8B05284CAB24}';
    KSPROPSETID_Linear: TGUID = '{5A2FFE80-16B9-11D0-A5D6-28DB04C10000}';


    // Midi definitions


    (* Formats `*)

    KSDATAFORMAT_TYPE_MUSIC: TGUID = '{E725D360-62CC-11CF-A5D6-28DB04C10000}';
    // 'mids' == MEDIATYPE_Midi

    KSDATAFORMAT_TYPE_MIDI: TGUID = '{7364696D-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_MIDI: TGUID = '{1D262760-E957-11CF-A5D6-28DB04C10000}';
    KSDATAFORMAT_SUBTYPE_MIDI_BUS: TGUID = '{2CA15FA0-6CFE-11CF-A5D6-28DB04C10000}';
    KSDATAFORMAT_SUBTYPE_RIFFMIDI: TGUID = '{4995DAF0-9EE6-11D0-A40E-00A0C9223196}';

(*
    KSDATAFORMAT_SUBTYPE_DIRECTMUSIC
    see DMusicKS.h
*)

    /////////////////////////////////////////////////////////////////////////
    // The major data type GUIDs that define the data packet encapsulation //
    /////////////////////////////////////////////////////////////////////////


    KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM: TGUID = '{36523B11-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_TYPE_STANDARD_PES_PACKET: TGUID = '{36523B12-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER: TGUID = '{36523B13-8EE5-11d1-8CA3-0060B057664A}';

    ///////////////////////////////////////////////////////////////////////////////
    // The minor data subtype GUIDs that define the exact class of the data type.//
    ///////////////////////////////////////////////////////////////////////////////

    KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO: TGUID = '{36523B21-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO: TGUID = '{36523B22-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO: TGUID = '{36523B23-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO: TGUID = '{36523B24-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO: TGUID = '{36523B25-8EE5-11d1-8CA3-0060B057664A}';

    ///////////////////////////////////////////////////////////////////////////////
    // The low-level specifier GUIDs that define the flavor of the data subtype. //
    // Some SUBTYPES, notably MPEG2_VIDEO, MPEG2_AUDIO have different dialects.  //
    // These specifiers are intended to be accompanied by a specifier structure. //
    ///////////////////////////////////////////////////////////////////////////////

    KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO: TGUID = '{36523B31-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO: TGUID = '{36523B32-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO: TGUID = '{36523B33-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO: TGUID = '{36523B34-8EE5-11d1-8CA3-0060B057664A}';
    KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO: TGUID = '{36523B35-8EE5-11d1-8CA3-0060B057664A}';

    //====================================================================================================
    //====================================================================================================
    //                              *** COMPATIBILITY WARNING ***
    // The *following* older DSS, MPEG, DVD & AC-3 GUID definitions are retained for backward compability.
    // These MPEG GUIDs should also be supported for compatibilty, but the above newer modes are still required.
    //====================================================================================================
    //====================================================================================================


    // DSS definitions



    KSDATAFORMAT_SUBTYPE_DSS_VIDEO: TGUID = '{a0af4f81-e163-11d0-bad9-00609744111a}';
    KSDATAFORMAT_SUBTYPE_DSS_AUDIO: TGUID = '{a0af4f82-e163-11d0-bad9-00609744111a}';


    // End of obsolete MPEG definitions.



    // mpeg 1 definitions

    KSDATAFORMAT_SUBTYPE_MPEG1Packet: TGUID = '{e436eb80-524f-11ce-9F53-0020af0ba770}';
    KSDATAFORMAT_SUBTYPE_MPEG1Payload: TGUID = '{e436eb81-524f-11ce-9F53-0020af0ba770}';

    // MEDIASUBTYPE_MPEG1Video
    KSDATAFORMAT_SUBTYPE_MPEG1Video: TGUID = '{e436eb86-524f-11ce-9f53-0020af0ba770}';


    //FORMAT_MPEGVideo
    KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO: TGUID = '{05589f82-c356-11ce-bf01-00aa0055595a}';


    // mpeg 2 definitions


    KSDATAFORMAT_TYPE_MPEG2_PES: TGUID = '{e06d8020-db46-11cf-b4d1-00805f6cbbea}';
    KSDATAFORMAT_TYPE_MPEG2_PROGRAM: TGUID = '{e06d8022-db46-11cf-b4d1-00805f6cbbea}';
    KSDATAFORMAT_TYPE_MPEG2_TRANSPORT: TGUID = '{e06d8023-db46-11cf-b4d1-00805f6cbbea}';
    KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO: TGUID = '{e06d8026-db46-11cf-b4d1-00805f6cbbea}';


    // use MPEGVIDEOINFO2 (defined below) with KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
    KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO: TGUID = '{e06d80e3-db46-11cf-b4d1-00805f6cbbea}';

    // Mpeg2 video properties

    KSPROPSETID_Mpeg2Vid: TGUID = '{C8E11B60-0CC9-11D0-BD69-003505C103A9}';


    // MPEG2 Audio definition

    KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO: TGUID = '{e06d802b-db46-11cf-b4d1-00805f6cbbea}';
    KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO: TGUID = '{e06d80e5-db46-11cf-b4d1-00805f6cbbea}';


    // DVD LPCM Audio definition

    KSDATAFORMAT_SUBTYPE_LPCM_AUDIO: TGUID = '{e06d8032-db46-11cf-b4d1-00805f6cbbea}';
    KSDATAFORMAT_SPECIFIER_LPCM_AUDIO: TGUID = '{e06d80e6-db46-11cf-b4d1-00805f6cbbea}';


    // AC-3 definition

    KSDATAFORMAT_SUBTYPE_AC3_AUDIO: TGUID = '{e06d802c-db46-11cf-b4d1-00805f6cbbea}';
    KSDATAFORMAT_SPECIFIER_AC3_AUDIO: TGUID = '{e06d80e4-db46-11cf-b4d1-00805f6cbbea}';
    KSPROPSETID_AC3: TGUID = '{BFABE720-6E1F-11D0-BCF2-444553540000}';


    // New formats enabled by CEA 861 specifciation
    KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL: TGUID = '{00000092-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO: TGUID = '{00000164-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DTS: TGUID = '{00000008-0000-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1: TGUID = '{00000003-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2: TGUID = '{00000004-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3: TGUID = '{00000005-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_AAC: TGUID = '{00000006-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC: TGUID = '{00000008-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO: TGUID = '{00000009-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS: TGUID = '{0000000a-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS_ATMOS: TGUID = '{0000010a-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD: TGUID = '{0000000b-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP: TGUID = '{0000000c-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MAT20: TGUID = '{0000010c-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MAT21: TGUID = '{0000030c-0cea-0010-8000-00aa00389b71}';
    KSDATAFORMAT_SUBTYPE_IEC61937_DST: TGUID = '{0000000d-0cea-0010-8000-00aa00389b71}';

    //MP3
    KSDATAFORMAT_SUBTYPE_MPEGLAYER3: TGUID = '{00000055-0000-0010-8000-00aa00389b71}';

    // AAC
    KSDATAFORMAT_SUBTYPE_MPEG_HEAAC: TGUID = '{00001610-0000-0010-8000-00aa00389b71}';

    //WMA STD
    KSDATAFORMAT_SUBTYPE_WMAUDIO2: TGUID = '{00000161-0000-0010-8000-00aa00389b71}';


    //WMA PRO
    KSDATAFORMAT_SUBTYPE_WMAUDIO3: TGUID = '{00000162-0000-0010-8000-00aa00389b71}';

    //WMA LOSSLESS
    KSDATAFORMAT_SUBTYPE_WMAUDIO_LOSSLESS: TGUID = '{00000163-0000-0010-8000-00aa00389b71}';

    // {$if (NTDDI_VERSION >= NTDDI_WINXP)


    // DTS and SDDS definitions (media subtype GUIDs)

    KSDATAFORMAT_SUBTYPE_DTS_AUDIO: TGUID = '{e06d8033-db46-11cf-b4d1-00805f6cbbea}';
    KSDATAFORMAT_SUBTYPE_SDDS_AUDIO: TGUID = '{e06d8034-db46-11cf-b4d1-00805f6cbbea}';
    //{$ENDIF}// (NTDDI_VERSION >= NTDDI_WINXP)


    // audio decoder output properties

    KSPROPSETID_AudioDecoderOut: TGUID = '{6ca6e020-43bd-11d0-bd6a-003505c103a9}';


    // subpicture definition

    KSDATAFORMAT_SUBTYPE_SUBPICTURE: TGUID = '{e06d802d-db46-11cf-b4d1-00805f6cbbea}';
    KSPROPSETID_DvdSubPic: TGUID = '{ac390460-43af-11d0-bd6a-003505c103a9}';
    KSPROPSETID_CopyProt: TGUID = '{0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3}';

    //===========================================================================
    // The following MUST match the structures in WinGDI.h and AMVideo.h
    //===========================================================================


    KSCATEGORY_TVTUNER: TGUID = '{a799a800-a46d-11d0-a18c-00a02401dcd4}';
    KSCATEGORY_CROSSBAR: TGUID = '{a799a801-a46d-11d0-a18c-00a02401dcd4}';
    KSCATEGORY_TVAUDIO: TGUID = '{a799a802-a46d-11d0-a18c-00a02401dcd4}';
    KSCATEGORY_VPMUX: TGUID = '{a799a803-a46d-11d0-a18c-00a02401dcd4}';
    KSCATEGORY_VBICODEC: TGUID = '{07dad660-22f1-11d1-a9f4-00c04fbbde8f}';

    // SUBTYPE_VPVideo
    KSDATAFORMAT_SUBTYPE_VPVideo: TGUID = '{5a9b6a40-1a22-11d1-bad9-00609744111a}';

    // SUBTYPE_VPVBI
    KSDATAFORMAT_SUBTYPE_VPVBI: TGUID = '{5a9b6a41-1a22-11d1-bad9-00609744111a}';



    // FORMAT_VideoInfo
    KSDATAFORMAT_SPECIFIER_VIDEOINFO: TGUID = '{05589f80-c356-11ce-bf01-00aa0055595a}';

    // FORMAT_VideoInfo2
    KSDATAFORMAT_SPECIFIER_VIDEOINFO2: TGUID = '{f72a76A0-eb0a-11d0-ace4-0000c0cc16ba}';

    // FORMAT_UVCH264Video
    KSDATAFORMAT_SPECIFIER_H264_VIDEO: TGUID = '{2017be05-6629-4248-aaed-7e1a47bc9b9c}';

    // FORMAT_JPEGImage
    KSDATAFORMAT_SPECIFIER_JPEG_IMAGE: TGUID = '{692fa379-d3e8-4651-b5b4-0b94b013eeaf}';

    // FORMAT_Image
    KSDATAFORMAT_SPECIFIER_IMAGE: TGUID = '{692fa379-d3e8-4651-b5b4-0b94b013eeaf}';

    // MEDIATYPE_Image: same as MFMEDIATYPE_Image
    KSDATAFORMAT_TYPE_IMAGE: TGUID = '{72178c23-e45b-11d5-bc2a-00b0d0f3f4ab}';

    // SUBTYPE_JPEG: same as WIC container format JPEG
    KSDATAFORMAT_SUBTYPE_JPEG: TGUID = '{19e4a5aa-5662-4fc5-a0c0-1758028e1057}';

    // SUBTYPE_IMAGE_RGB32: same as MFVideoFormat_RGB32
    KSDATAFORMAT_SUBTYPE_IMAGE_RGB32: TGUID = '{00000016-0000-0010-8000-00aa00389b71}';

    //{$if (NTDDI_VERSION >= NTDDI_WIN10)}

    // KSDATAFORMAT_SUBTYPE_L8:
    KSDATAFORMAT_SUBTYPE_L8: TGUID = '{00000032-0000-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_L8_IR:
    KSDATAFORMAT_SUBTYPE_L8_IR: TGUID = '{00000032-0002-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_L8_CUSTOM:
    KSDATAFORMAT_SUBTYPE_L8_CUSTOM: TGUID = '{00000032-8000-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_L16:
    KSDATAFORMAT_SUBTYPE_L16: TGUID = '{00000051-0000-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_L16_IR:
    KSDATAFORMAT_SUBTYPE_L16_IR: TGUID = '{00000051-0002-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_D16:
    KSDATAFORMAT_SUBTYPE_D16: TGUID = '{00000050-0004-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_L16_CUSTOM:
    KSDATAFORMAT_SUBTYPE_L16_CUSTOM: TGUID = '{00000051-8000-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_MJPG_IR:
    KSDATAFORMAT_SUBTYPE_MJPG_IR: TGUID = '{47504a4d-0002-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_MJPG_DEPTH:
    KSDATAFORMAT_SUBTYPE_MJPG_DEPTH: TGUID = '{47504a4d-0004-0010-8000-00aa00389b71}';

    // KSDATAFORMAT_SUBTYPE_MJPG_CUSTOM:
    KSDATAFORMAT_SUBTYPE_MJPG_CUSTOM: TGUID = '{47504a4d-8000-0010-8000-00aa00389b71}';
    //{$ENDIF} //(NTDDI_VERSION >= NTDDI_WIN10)

    // MEDIATYPE_AnalogVideo
    KSDATAFORMAT_TYPE_ANALOGVIDEO: TGUID = '{0482dde1-7817-11cf-8a03-00aa006ecb65}';

    // FORMAT_AnalogVideo
    KSDATAFORMAT_SPECIFIER_ANALOGVIDEO: TGUID = '{0482dde0-7817-11cf-8a03-00aa006ecb65}';

    // {$if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)
    // MEDIATYPE_AnalogAudio
    KSDATAFORMAT_TYPE_ANALOGAUDIO: TGUID = '{0482DEE1-7817-11cf-8a03-00aa006ecb65}';
    //{$ENDIF} // XP SP2 and later (chronologically)

    // FORMAT_VBI
    KSDATAFORMAT_SPECIFIER_VBI: TGUID = '{f72a76e0-eb0a-11d0-ace4-0000c0cc16ba}';

    // MEDIATYPE_VBI
    KSDATAFORMAT_TYPE_VBI: TGUID = '{f72a76e1-eb0a-11d0-ace4-0000c0cc16ba}';

    // SUBTYPE_RAW8
    KSDATAFORMAT_SUBTYPE_RAW8: TGUID = '{ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf}';

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)

    // MEDIASUBTYPE_CC
    KSDATAFORMAT_SUBTYPE_CC: TGUID = '{33214CC1-011F-11D2-B4B1-00A0D102CFBE}';

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    // MEDIASUBTYPE_NABTS
    KSDATAFORMAT_SUBTYPE_NABTS: TGUID = '{f72a76e2-eb0a-11d0-ace4-0000c0cc16ba}';

    // MEDIASUBTYPE_TELETEXT
    KSDATAFORMAT_SUBTYPE_TELETEXT: TGUID = '{f72a76e3-eb0a-11d0-ace4-0000c0cc16ba}';

    KSPROPSETID_VBICAP_PROPERTIES: TGUID = '{F162C607-7B35-496f-AD7F-2DCA3B46B718}';
    KSDATAFORMAT_TYPE_NABTS: TGUID = '{E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F}';
    KSDATAFORMAT_SUBTYPE_NABTS_FEC: TGUID = '{E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F}';
    KSPROPSETID_VBICodecFiltering: TGUID = '{cafeb0ca-8715-11d0-bd6a-0035c0edbabe}';

    // Standard Pin Names for the video capture filter
    //===========================================================================
    PINNAME_VIDEO_CAPTURE: TGUID = '{FB6C4281-0353-11d1-905F-0000C0CC16BA}';

    // {$if (NTDDI_VERSION >= NTDDI_WINXP)
    PINNAME_VIDEO_CC_CAPTURE: TGUID = '{1AAD8061-012D-11d2-B4B1-00A0D102CFBE}';
    PINNAME_VIDEO_NABTS_CAPTURE: TGUID = '{29703660-498A-11d2-B4B1-00A0D102CFBE}';
    // {$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    PINNAME_VIDEO_PREVIEW: TGUID = '{FB6C4282-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_ANALOGVIDEOIN: TGUID = '{FB6C4283-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_VBI: TGUID = '{FB6C4284-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_VIDEOPORT: TGUID = '{FB6C4285-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_NABTS: TGUID = '{FB6C4286-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_EDS: TGUID = '{FB6C4287-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_TELETEXT: TGUID = '{FB6C4288-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_CC: TGUID = '{FB6C4289-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_STILL: TGUID = '{FB6C428A-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_IMAGE: TGUID = '{38A0CD98-D49B-4ce8-B48A-344667A17830}';
    PINNAME_VIDEO_TIMECODE: TGUID = '{FB6C428B-0353-11d1-905F-0000C0CC16BA}';
    PINNAME_VIDEO_VIDEOPORT_VBI: TGUID = '{FB6C428C-0353-11d1-905F-0000C0CC16BA}';


    //Video memory capture KSPROPSETID

    KSPROPSETID_VramCapture: TGUID = '{E73FACE3-2880-4902-B799-88D0CD634E0F}';

    // Sceanrio ID for secure buffer for camera
    KS_SECURE_CAMERA_SCENARIO_ID: TGUID = '{AE53FC6E-8D89-4488-9D2E-4D008731C5FD}';
    KSPROPSETID_MPEG4_MediaType_Attributes: TGUID = '{FF6C4BFA-07A9-4c7b-A237-672F9D68065F}';

    KSEVENTSETID_DynamicFormatChange: TGUID = '{162AC456-83D7-4239-96DF-C75FFA138BC6}';
    PROPSETID_ALLOCATOR_CONTROL: TGUID = '{53171960-148E-11d2-9979-0000C0CC16BA}';

    PROPSETID_VIDCAP_VIDEOPROCAMP: TGUID = '{C6E13360-30AC-11d0-A18C-00A0C9118956}';
    PROPSETID_VIDCAP_SELECTOR: TGUID = '{1ABDAECA-68B6-4F83-9371-B413907C7B9F}';
    PROPSETID_TUNER: TGUID = '{6a2e0605-28e4-11d0-a18c-00a0c9118956}';
    EVENTSETID_TUNER: TGUID = '{6a2e0606-28e4-11d0-a18c-00a0c9118956}';
    EVENTSETID_VIDEODECODER: TGUID = '{6a2e0621-28e4-11d0-a18c-00a0c9118956}';
    KSEVENTSETID_CameraAsyncControl: TGUID = '{22A11754-9701-4088-B33F-6B9CBC52DF5E}';
    PROPSETID_VIDCAP_CAMERACONTROL: TGUID = '{C6E13370-30AC-11d0-A18C-00A0C9118956}';
    PROPSETID_VIDCAP_CAMERACONTROL_FLASH: TGUID = '{785E8F49-63A2-4144-AB70-FFB278FA26CE}';
    PROPSETID_VIDCAP_CAMERACONTROL_REGION_OF_INTEREST: TGUID = '{9D12D198-F86C-4fed-B023-5D87653DA793}';
    EVENTSETID_VIDCAP_CAMERACONTROL_REGION_OF_INTEREST: TGUID = '{2FDFFC5D-C732-4BA6-B5DF-6B4D7FC88B8B}';
    PROPSETID_VIDCAP_CAMERACONTROL_IMAGE_PIN_CAPABILITY: TGUID = '{9D3D7BBF-5C6D-4138-BB00-584EDD20F7C5}';
    KSPROPERTYSETID_ExtendedCameraControl: TGUID = '{1CB79112-C0D2-4213-9CA6-CD4FDB927972}';
    KSEVENTSETID_ExtendedCameraControl: TGUID = '{571C92C9-13A2-47E3-A649-D2A778166384}';

    //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)}
    KSEVENTSETID_CameraEvent: TGUID = '{7899B2E0-6B43-4964-9D2A-A21F4061F576}';
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)

    //===========================================================================
    // USB Video Class Definitions

    KSNODETYPE_VIDEO_STREAMING: TGUID = '{DFF229E1-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_INPUT_TERMINAL: TGUID = '{DFF229E2-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_OUTPUT_TERMINAL: TGUID = '{DFF229E3-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_SELECTOR: TGUID = '{DFF229E4-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_PROCESSING: TGUID = '{DFF229E5-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_CAMERA_TERMINAL: TGUID = '{DFF229E6-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_INPUT_MTT: TGUID = '{DFF229E7-F70F-11D0-B917-00A0C9223196}';
    KSNODETYPE_VIDEO_OUTPUT_MTT: TGUID = '{DFF229E8-F70F-11D0-B917-00A0C9223196}';
    // {$ENDIF} // XP SP2 and later (chronologically)

    PROPSETID_VIDCAP_VIDEOENCODER: TGUID = '{6a2e0610-28e4-11d0-a18c-00a0c9118956}';
    PROPSETID_VIDCAP_VIDEODECODER: TGUID = '{C6E13350-30AC-11d0-A18C-00A0C9118956}';
    PROPSETID_VIDCAP_CAMERACONTROL_VIDEO_STABILIZATION: TGUID = '{43964BD3-7716-404e-8BE1-D299B20E50FD}';

    // Per Frame Settings
    KSPROPERTYSETID_PerFrameSettingControl: TGUID = '{F1F3E261-DEE6-4537-BFF5-EE206DB54AAC}';

    KSCAMERAPROFILE_Legacy: TGUID = '{B4894D81-62B7-4EEC-8740-80658C4A9D3E}';
    KSCAMERAPROFILE_VideoRecording: TGUID = '{A0E517E8-8F8C-4F6F-9A57-46FC2F647EC0}';
    KSCAMERAPROFILE_HighQualityPhoto: TGUID = '{32440725-961B-4CA3-B5B2-854E719D9E1B}';
    KSCAMERAPROFILE_BalancedVideoAndPhoto: TGUID = '{6B52B017-42C7-4A21-BFE3-23F009149887}';
    KSCAMERAPROFILE_VideoConferencing: TGUID = '{C5444A88-E1BF-4597-B2DD-9E1EAD864BB8}';
    KSCAMERAPROFILE_PhotoSequence: TGUID = '{02399D9D-4EE8-49BA-BC07-5FF156531413}';
    KSCAMERAPROFILE_FaceAuth_Mode: TGUID = '{81361B22-700B-4546-A2D4-C52E907BFC27}';
    KSCAMERAPROFILE_HighFrameRate: TGUID = '{566E6113-8C35-48E7-B89F-D23FDC1219DC}';
    KSCAMERAPROFILE_HDRWithWCGVideo: TGUID = '{4B27C336-4924-4989-B994-FDAF1DC7CD85}';
    KSCAMERAPROFILE_HDRWithWCGPhoto: TGUID = '{9BF6F1FF-B555-4625-B326-A46DEF318FB7}';
    KSCAMERAPROFILE_VariablePhotoSequence: TGUID = '{9FF2CB56-E75A-49B1-A928-9985D5946F87}';
    KSCAMERAPROFILE_VideoHDR8: TGUID = '{D4F3F4EC-BDFF-4314-B1D4-008E281F74E7}';


    PROPSETID_EXT_DEVICE: TGUID = '{B5730A90-1A2C-11cf-8C23-00AA006B6814}';
    PROPSETID_EXT_TRANSPORT: TGUID = '{A03CD5F0-3045-11cf-8C44-00AA006B6814}';
    PROPSETID_TIMECODE_READER: TGUID = '{9B496CE1-811B-11cf-8C77-00AA006B6814}';
    KSEVENTSETID_EXTDEV_Command: TGUID = '{109c7988-b3cb-11d2-b48e-006097b3391b}';

    PROPSETID_VIDCAP_CROSSBAR: TGUID = '{6a2e0640-28e4-11d0-a18c-00a0c9118956}';
    EVENTSETID_CROSSBAR: TGUID = '{6a2e0641-28e4-11d0-a18c-00a0c9118956}';
    PROPSETID_VIDCAP_TVAUDIO: TGUID = '{6a2e0650-28e4-11d0-a18c-00a0c9118956}';
    KSEVENTSETID_VIDCAP_TVAUDIO: TGUID = '{6a2e0651-28e4-11d0-a18c-00a0c9118956}';
    PROPSETID_VIDCAP_VIDEOCOMPRESSION: TGUID = '{C6E13343-30AC-11d0-A18C-00A0C9118956}';

    // MEDIASUBTYPE_Overlay
    KSDATAFORMAT_SUBTYPE_OVERLAY: TGUID = '{e436eb7f-524f-11ce-9f53-0020af0ba770}';
    KSPROPSETID_OverlayUpdate: TGUID = '{490EA5CF-7681-11D1-A21C-00A0C9223196}';

    PROPSETID_VIDCAP_VIDEOCONTROL: TGUID = '{6a2e0670-28e4-11d0-a18c-00a0c9118956}';
    PROPSETID_VIDCAP_DROPPEDFRAMES: TGUID = '{C6E13344-30AC-11d0-A18C-00A0C9118956}';

    // VPE
    KSPROPSETID_VPConfig: TGUID = '{bc29a660-30e3-11d0-9e69-00c04fd7c15b}';
    KSPROPSETID_VPVBIConfig: TGUID = '{ec529b00-1a1f-11d1-bad9-00609744111a}';

    // IBasicAudio
    CLSID_KsIBasicAudioInterfaceHandler: TGUID = '{b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d}';

    //  IVPNotify event notification
    KSEVENTSETID_VPNotify: TGUID = '{20c5598e-d3c8-11d0-8dfc-00c04fd7c08b}';
    //  VIDCAPTOSTI event notification
    KSEVENTSETID_VIDCAPTOSTI: TGUID = '{DB47DE20-F628-11d1-BA41-00A0C90D2B05}';
    //  IVPVBINotify event notification
    KSEVENTSETID_VPVBINotify: TGUID = '{ec529b01-1a1f-11d1-bad9-00609744111a}';

    // closed caption information
    KSDATAFORMAT_TYPE_AUXLine21Data: TGUID = '{670aea80-3a82-11d0-b79b-00aa003767a7}';
    KSDATAFORMAT_SUBTYPE_Line21_BytePair: TGUID = '{6e8d4a22-310c-11d0-b79a-00aa003767a7}';
    KSDATAFORMAT_SUBTYPE_Line21_GOPPacket: TGUID = '{6e8d4a23-310c-11d0-b79a-00aa003767a7}';

    // DVD encrypted PACK format type definition
    KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK: TGUID = '{ed0b916a-044d-11d1-aa78-00c04fc31d60}';

    KSPROPSETID_TSRateChange: TGUID = '{A503C5C0-1D1D-11D1-AD80-444553540000}';

    //===========================================================================
    //ENCODER API DEFINITIONS
    //===========================================================================
    KSCATEGORY_ENCODER: TGUID = '{19689BF6-C384-48fd-AD51-90E58C79F70B}';
    KSCATEGORY_MULTIPLEXER: TGUID = '{7A5DE1D3-01A1-452c-B481-4FA2B96271E8}';
    ENCAPIPARAM_BITRATE: TGUID = '{49CC4C43-CA83-4ad4-A9AF-F3696AF666DF}';
    ENCAPIPARAM_PEAK_BITRATE: TGUID = '{703F16A9-3D48-44a1-B077-018DFF915D19}';
    ENCAPIPARAM_BITRATE_MODE: TGUID = '{EE5FB25C-C713-40d1-9D58-C0D7241E250F}';

    CODECAPI_CHANGELISTS: TGUID = '{62B12ACF-F6B0-47D9-9456-96F22C4E0B9D}';
    CODECAPI_VIDEO_ENCODER: TGUID = '{7112E8E1-3D03-47EF-8E60-03F1CF537301}';
    CODECAPI_AUDIO_ENCODER: TGUID = '{B9D19A3E-F897-429C-BC46-8138B7272B2D}';
    CODECAPI_SETALLDEFAULTS: TGUID = '{6C5E6A7C-ACF8-4F55-A999-1A628109051B}';
    CODECAPI_ALLSETTINGS: TGUID = '{6A577E92-83E1-4113-ADC2-4FCEC32F83A1}';
    CODECAPI_SUPPORTSEVENTS: TGUID = '{0581AF97-7693-4DBD-9DCA-3F9EBD6585A1}';
    CODECAPI_CURRENTCHANGELIST: TGUID = '{1CB14E83-7D72-4657-83FD-47A2C5B9D13D}';

    KSPROPSETID_Jack: TGUID = '{4509F757-2D46-4637-8E62-CE7DB944F57B}';

    // Audio Buffer Duration
    KSPROPSETID_AudioBufferDuration: TGUID = '{4E73C07F-23CC-4955-A7EA-3DA502496290}';

    KSPROPSETID_AudioEngine: TGUID = '{3A2F82DC-886F-4BAA-9EB4-082B9025C536}';

    KSPROPSETID_AudioSignalProcessing: TGUID = '{4F67B528-30C9-40DE-B2FB-859DDD1F3470}';
    KSATTRIBUTEID_AUDIOSIGNALPROCESSING_MODE: TGUID = '{E1F89EB5-5F46-419B-967B-FF6770B98401}';
    AUDIO_SIGNALPROCESSINGMODE_DEFAULT: TGUID = '{C18E2F7E-933D-4965-B7D1-1EEF228D2AF3}';
    AUDIO_SIGNALPROCESSINGMODE_RAW: TGUID = '{9E90EA20-B493-4FD1-A1A8-7E1361A956CF}';


    // UUIDs defined for Bluetooth Midi

    //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS1)}

    // Bluetooth MIDI service UUID
    BLUETOOTHLE_MIDI_SERVICE_UUID: TGUID = '{03B80E5A-EDE8-4B33-A751-6CE34EC4C700}';
    // Bluetooth MIDI IO Characteristic UUID
    BLUETOOTH_MIDI_DATAIO_CHARACTERISTIC: TGUID = '{7772E5DB-3868-4112-A1A9-F2669D106BF3}';


    // UUID for Audio Processing Object (APO) device class
    APO_CLASS_UUID: TGUID = '{5989fce8-9cd0-467d-8a6a-5419e31529d4}';


    // UUID for audio endpoint device class
    AUDIOENDPOINT_CLASS_UUID: TGUID = '{C166523C-FE0C-4A94-A586-F1A80CFBBF3E}';

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS1)

    //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}

    // Communications mode specifies that the application expects VoIP specific signal processing at the lowest latency and the hardware preferred sample rate for wideband speech (such as 16 kHz).
    // For both Capture and Render.
    AUDIO_SIGNALPROCESSINGMODE_COMMUNICATIONS: TGUID = '{98951333-B9CD-48B1-A0A3-FF40682D73F7}';

    // Speech mode specifies that the application expects speech recognition specific signal processing at the lowest latency and the hardware preferred sample rate for wideband speech (such as 16 kHz).
    // For Capture only.
    AUDIO_SIGNALPROCESSINGMODE_SPEECH: TGUID = '{FC1CFC9B-B9D6-4CFA-B5E0-4BB2166878B2}';

    // Notification Mode
    // For both render and capture.
    AUDIO_SIGNALPROCESSINGMODE_NOTIFICATION: TGUID = '{9CF2A70B-F377-403B-BD6B-360863E0355C}';

    // Media Mode specifies that the application expects post processing suitable for media content if available or else the same treatments as Default mode.
    // For Render only.
    AUDIO_SIGNALPROCESSINGMODE_MEDIA: TGUID = '{4780004E-7133-41D8-8C74-660DADD2C0EE}';

    // Movie Mode specifies that the application expects post processing suitable for movie or video content if available or else the same treatments as Default mode.
    AUDIO_SIGNALPROCESSINGMODE_MOVIE: TGUID = '{B26FEB0D-EC94-477C-9494-D1AB8E753F6E}';

    //{$ENDIF}

    AUDIO_EFFECT_TYPE_ACOUSTIC_ECHO_CANCELLATION: TGUID = '{6f64adbe-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_NOISE_SUPPRESSION: TGUID = '{6f64adbf-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_AUTOMATIC_GAIN_CONTROL: TGUID = '{6f64adc0-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_BEAMFORMING: TGUID = '{6f64adc1-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_CONSTANT_TONE_REMOVAL: TGUID = '{6f64adc2-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_EQUALIZER: TGUID = '{6f64adc3-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_LOUDNESS_EQUALIZER: TGUID = '{6f64adc4-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_BASS_BOOST: TGUID = '{6f64adc5-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_VIRTUAL_SURROUND: TGUID = '{6f64adc6-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_VIRTUAL_HEADPHONES: TGUID = '{6f64adc7-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_SPEAKER_FILL: TGUID = '{6f64adc8-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_ROOM_CORRECTION: TGUID = '{6f64adc9-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_BASS_MANAGEMENT: TGUID = '{6f64adca-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_ENVIRONMENTAL_EFFECTS: TGUID = '{6f64adcb-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_SPEAKER_PROTECTION: TGUID = '{6f64adcc-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_SPEAKER_COMPENSATION: TGUID = '{6f64adcd-8211-11e2-8c70-2c27d7f001fa}';
    AUDIO_EFFECT_TYPE_DYNAMIC_RANGE_COMPRESSION: TGUID = '{6f64adce-8211-11e2-8c70-2c27d7f001fa}';

    //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS2)}
    // Interface to get audio modules information.
    KSPROPSETID_AudioModule: TGUID = '{C034FDB0-FF75-47C8-AA3C-EE46716B50C6}';
    // Audio module notification definitions.
    KSNOTIFICATIONID_AudioModule: TGUID = '{9C2220F0-D9A6-4D5C-A036-573857FD50D2}';

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS2)

    DDVPTYPE_E_HREFH_VREFH: TGUID = '{54F39980-DA60-11CF-9B06-00A0C903A3B8}';
    DDVPTYPE_E_HREFL_VREFL: TGUID = '{E09C77E0-DA60-11CF-9B06-00A0C903A3B8}';


const
    DEVPKEY_KsAudio_PacketSize_Constraints: TDEVPROPKEY =
        (fmtid: '{13E004D6-B066-43BD-913B-A415CD13DA87}'; pid: 2);  // DEVPROP_TYPE_BINARY

    //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS5)
    // This property is the symbolic link to an interface of type 'GUID_KSCATEGORY_AUDIO_CONTROLLER_INTERFACE' published
    // by the KS Filter or miniport drivers on the KSCATEGORY_AUDIO interface to indicate the audio system about the 'controller'
    // device interface symbolic link that will provide extended information about this audio endpoint
    DEVPKEY_KsAudio_Controller_DeviceInterface_Path: TDEVPROPKEY =
        (fmtid: '{13E004D6-B066-43BD-913B-A415CD13DA87}'; pid: 3); // DEVPROP_TYPE_STRING
    // {$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS5)

    DEVPKEY_KsAudio_PacketSize_Constraints2: TDEVPROPKEY =
        (fmtid: '{9404F781-7191-409B-8B0B-80BF6EC229AE}'; pid: 2);     // DEVPROP_TYPE_BINARY

const
    WAVE_FORMAT_EXTENSIBLE = $FFFE;

    // DirectSound buffer flags
    KSDSOUND_BUFFER_PRIMARY = $00000001;
    KSDSOUND_BUFFER_STATIC = $00000002;
    KSDSOUND_BUFFER_LOCHARDWARE = $00000004;
    KSDSOUND_BUFFER_LOCSOFTWARE = $00000008;

    // DirectSound buffer control flags
    KSDSOUND_BUFFER_CTRL_3D = $00000001;
    KSDSOUND_BUFFER_CTRL_FREQUENCY = $00000002;
    KSDSOUND_BUFFER_CTRL_PAN = $00000004;
    KSDSOUND_BUFFER_CTRL_VOLUME = $00000008;
    KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY = $00000010;

    KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE = (-1);
    KSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN = 5;
    KSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW = 10;
    KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE = 20;
    KSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX = 180;

    KSDSOUND_3D_MODE_NORMAL = $00000000;
    KSDSOUND_3D_MODE_HEADRELATIVE = $00000001;
    KSDSOUND_3D_MODE_DISABLE = $00000002;

    KSDSOUND_BUFFER_CTRL_HRTF_3D = $40000000;

    // Audio quality constants
    KSAUDIO_QUALITY_WORST = $0;
    KSAUDIO_QUALITY_PC = $1;
    KSAUDIO_QUALITY_BASIC = $2;
    KSAUDIO_QUALITY_ADVANCED = $3;

    // Audio CPU resource constants
    KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU = $00000000;
    KSAUDIO_CPU_RESOURCES_HOST_CPU = $7FFFFFFF;


    // Speaker Positions:
    SPEAKER_FRONT_LEFT = $1;
    SPEAKER_FRONT_RIGHT = $2;
    SPEAKER_FRONT_CENTER = $4;
    SPEAKER_LOW_FREQUENCY = $8;
    SPEAKER_BACK_LEFT = $10;
    SPEAKER_BACK_RIGHT = $20;
    SPEAKER_FRONT_LEFT_OF_CENTER = $40;
    SPEAKER_FRONT_RIGHT_OF_CENTER = $80;
    SPEAKER_BACK_CENTER = $100;
    SPEAKER_SIDE_LEFT = $200;
    SPEAKER_SIDE_RIGHT = $400;
    SPEAKER_TOP_CENTER = $800;
    SPEAKER_TOP_FRONT_LEFT = $1000;
    SPEAKER_TOP_FRONT_CENTER = $2000;
    SPEAKER_TOP_FRONT_RIGHT = $4000;
    SPEAKER_TOP_BACK_LEFT = $8000;
    SPEAKER_TOP_BACK_CENTER = $10000;
    SPEAKER_TOP_BACK_RIGHT = $20000;

    // Bit mask locations reserved for future use
    SPEAKER_RESERVED = $7FFC0000;

    // Used to specify that any possible permutation of speaker configurations
    SPEAKER_ALL = $80000000;

    // DirectSound Speaker Config
    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KSAUDIO_SPEAKER_DIRECTOUT = 0;
    //{$ENDIF}
    KSAUDIO_SPEAKER_MONO = (SPEAKER_FRONT_CENTER);
    KSAUDIO_SPEAKER_1POINT1 = (SPEAKER_FRONT_CENTER or SPEAKER_LOW_FREQUENCY);
    KSAUDIO_SPEAKER_STEREO = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT);
    KSAUDIO_SPEAKER_2POINT1 = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_LOW_FREQUENCY);
    KSAUDIO_SPEAKER_3POINT0 = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_FRONT_CENTER);
    KSAUDIO_SPEAKER_3POINT1 = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_FRONT_CENTER or
        SPEAKER_LOW_FREQUENCY);
    KSAUDIO_SPEAKER_QUAD = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_BACK_LEFT or
        SPEAKER_BACK_RIGHT);
    KSAUDIO_SPEAKER_SURROUND = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_FRONT_CENTER or
        SPEAKER_BACK_CENTER);
    KSAUDIO_SPEAKER_5POINT0 = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_FRONT_CENTER or
        SPEAKER_SIDE_LEFT or SPEAKER_SIDE_RIGHT);
    KSAUDIO_SPEAKER_5POINT1 = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_FRONT_CENTER or
        SPEAKER_LOW_FREQUENCY or SPEAKER_BACK_LEFT or SPEAKER_BACK_RIGHT);
    KSAUDIO_SPEAKER_7POINT0 = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_FRONT_CENTER or
        SPEAKER_BACK_LEFT or SPEAKER_BACK_RIGHT or SPEAKER_SIDE_LEFT or SPEAKER_SIDE_RIGHT);
    KSAUDIO_SPEAKER_7POINT1 = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or SPEAKER_FRONT_CENTER or
        SPEAKER_LOW_FREQUENCY or SPEAKER_BACK_LEFT or SPEAKER_BACK_RIGHT or
        SPEAKER_FRONT_LEFT_OF_CENTER or SPEAKER_FRONT_RIGHT_OF_CENTER);

    //if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1) }

    KSAUDIO_SPEAKER_5POINT1_SURROUND = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or
        SPEAKER_FRONT_CENTER or SPEAKER_LOW_FREQUENCY or SPEAKER_SIDE_LEFT or SPEAKER_SIDE_RIGHT);
    KSAUDIO_SPEAKER_7POINT1_SURROUND = (SPEAKER_FRONT_LEFT or SPEAKER_FRONT_RIGHT or
        SPEAKER_FRONT_CENTER or SPEAKER_LOW_FREQUENCY or SPEAKER_BACK_LEFT or SPEAKER_BACK_RIGHT or
        SPEAKER_SIDE_LEFT or SPEAKER_SIDE_RIGHT);
    // The following are obsolete 5.1 and 7.1 settings (they lack side speakers).  Note this means
    // that the default 5.1 and 7.1 settings (KSAUDIO_SPEAKER_5POINT1 and KSAUDIO_SPEAKER_7POINT1 are
    // similarly obsolete but are unchanged for compatibility reasons).
    KSAUDIO_SPEAKER_5POINT1_BACK = KSAUDIO_SPEAKER_5POINT1;
    KSAUDIO_SPEAKER_7POINT1_WIDE = KSAUDIO_SPEAKER_7POINT1;

    //{$ENDIF} // XP SP2 and later (chronologically)

    // DVD Speaker Positions
    KSAUDIO_SPEAKER_GROUND_FRONT_LEFT = SPEAKER_FRONT_LEFT;
    KSAUDIO_SPEAKER_GROUND_FRONT_CENTER = SPEAKER_FRONT_CENTER;
    KSAUDIO_SPEAKER_GROUND_FRONT_RIGHT = SPEAKER_FRONT_RIGHT;
    KSAUDIO_SPEAKER_GROUND_REAR_LEFT = SPEAKER_BACK_LEFT;
    KSAUDIO_SPEAKER_GROUND_REAR_RIGHT = SPEAKER_BACK_RIGHT;
    KSAUDIO_SPEAKER_TOP_MIDDLE = SPEAKER_TOP_CENTER;
    KSAUDIO_SPEAKER_SUPER_WOOFER = SPEAKER_LOW_FREQUENCY;

    // Internal topology node pin definitions

    KSNODEPIN_STANDARD_IN = 1;
    KSNODEPIN_STANDARD_OUT = 0;

    KSNODEPIN_SUM_MUX_IN = 1;  // can be >= 1
    KSNODEPIN_SUM_MUX_OUT = 0;

    KSNODEPIN_DEMUX_IN = 0;
    KSNODEPIN_DEMUX_OUT = 1;  // can be >= 1

    //{$if (NTDDI_VERSION < NTDDI_VISTA)}

    KSNODEPIN_AEC_RENDER_IN = 1;
    KSNODEPIN_AEC_RENDER_OUT = 0;
    KSNODEPIN_AEC_CAPTURE_IN = 2;
    KSNODEPIN_AEC_CAPTURE_OUT = 3;
    //{$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)


    // {$if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)}
    AEC_STATUS_FD_HISTORY_UNINITIALIZED = $0;
    AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED = $1;
    AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED = $2;
    AEC_STATUS_FD_CURRENTLY_CONVERGED = $8;

    AEC_MODE_PASS_THROUGH = $0;
    AEC_MODE_HALF_DUPLEX = $1;
    AEC_MODE_FULL_DUPLEX = $2;
    // {$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

    // {$if (NTDDI_VERSION < NTDDI_WS03)}
    KSPROPERTY_WAVE_QUEUED_POSITION = $00000001;
    KSMETHOD_WAVE_QUEUED_BREAKLOOP = $00000001;

    //{$ENDIF} // (NTDDI_VERSION < NTDDI_WS03)

    KSWAVE_COMPATCAPS_INPUT = $00000000;
    KSWAVE_COMPATCAPS_OUTPUT = $00000001;

    KSWAVE_BUFFER_ATTRIBUTEF_LOOPING = $00000001;
    KSWAVE_BUFFER_ATTRIBUTEF_STATIC = $00000002;

    SYSAUDIO_FLAGS_DONT_COMBINE_PINS = $00000001;
    SYSAUDIO_FLAGS_CLEAR_PREFERRED = $00000002;


    // bit field definitions for MPEG2 VIDEO mode


    KSMPEGVIDMODE_PANSCAN = $0001;
    KSMPEGVIDMODE_LTRBOX = $0002;
    KSMPEGVIDMODE_SCALE = $0004;

    KSAC3_ALTERNATE_AUDIO_1 = 1;
    KSAC3_ALTERNATE_AUDIO_2 = 2;
    KSAC3_ALTERNATE_AUDIO_BOTH = 3;

    KSAC3_SERVICE_MAIN_AUDIO = 0;
    KSAC3_SERVICE_NO_DIALOG = 1;
    KSAC3_SERVICE_VISUALLY_IMPAIRED = 2;
    KSAC3_SERVICE_HEARING_IMPAIRED = 3;
    KSAC3_SERVICE_DIALOG_ONLY = 4;
    KSAC3_SERVICE_COMMENTARY = 5;
    KSAC3_SERVICE_EMERGENCY_FLASH = 6;
    KSAC3_SERVICE_VOICE_OVER = 7;

    KSAUDDECOUTMODE_STEREO_ANALOG = $0001;
    KSAUDDECOUTMODE_PCM_51 = $0002;
    KSAUDDECOUTMODE_SPDIFF = $0004;


    // CGMS Copy Protection Flags


    KS_DVD_CGMS_RESERVED_MASK = $00000078;

    KS_DVD_CGMS_COPY_PROTECT_MASK = $00000018;
    KS_DVD_CGMS_COPY_PERMITTED = $00000000;
    KS_DVD_CGMS_COPY_ONCE = $00000010;
    KS_DVD_CGMS_NO_COPY = $00000018;

    KS_DVD_COPYRIGHT_MASK = $00000040;
    KS_DVD_NOT_COPYRIGHTED = $00000000;
    KS_DVD_COPYRIGHTED = $00000040;

    KS_DVD_SECTOR_PROTECT_MASK = $00000020;
    KS_DVD_SECTOR_NOT_PROTECTED = $00000000;
    KS_DVD_SECTOR_PROTECTED = $00000020;

    (* constants for the biCompression field *)
    KS_BI_RGB = 0;
    KS_BI_RLE8 = 1;
    KS_BI_RLE4 = 2;
    KS_BI_BITFIELDS = 3;
    KS_BI_JPEG = 4;

    (* constants for palettes *)
    KS_iPALETTE_COLORS = 256;    // Maximum colours in palette
    KS_iEGA_COLORS = 16;        // Number colours in EGA palette
    KS_iMASK_COLORS = 3;        // Maximum three components
    KS_iTRUECOLOR = 16;         // Minimum true colour device
    KS_iRED = 0;                 // Index position for RED mask
    KS_iGREEN = 1;                // Index position for GREEN mask
    KS_iBLUE = 2;               // Index position for BLUE mask
    KS_iPALETTE = 8;             // Maximum colour depth using a palette
    KS_iMAXBITS = 8;             // Maximum bits per colour component
    // ToDo KS_SIZE_EGA_PALETTE = (KS_iEGA_COLORS * sizeof(TKS_RGBQUAD));
    // ToDo KS_SIZE_PALETTE = (KS_iPALETTE_COLORS * sizeof(TKS_RGBQUAD));

    KS_SIZE_MASKS = (KS_iMASK_COLORS * sizeof(DWORD));
    // ToDo   KS_SIZE_PREHEADER = (FIELD_OFFSET(KS_VIDEOINFOHEADER, bmiHeader));

    // VBI Sampling Rates
    KS_VBIDATARATE_NABTS = (5727272);
    KS_VBIDATARATE_CC = (503493);    // ~= 1/1.986125e-6
    KS_VBISAMPLINGRATE_4X_NABTS = (4 * KS_VBIDATARATE_NABTS);
    KS_VBISAMPLINGRATE_47X_NABTS = (27000000);
    KS_VBISAMPLINGRATE_5X_NABTS = (5 * KS_VBIDATARATE_NABTS);

    KS_47NABTS_SCALER = (KS_VBISAMPLINGRATE_47X_NABTS / KS_VBIDATARATE_NABTS);

    KS_TVTUNER_CHANGE_BEGIN_TUNE = $0001;  // Starting a tuning operation
    KS_TVTUNER_CHANGE_END_TUNE = $0002;  // Ending a tuning operation

    KS_INTERLACE_IsInterlaced = $00000001;  // if 0, other interlace bits are irrelevent
    KS_INTERLACE_1FieldPerSample = $00000002;  // else 2 fields per media sample
    KS_INTERLACE_Field1First = $00000004;
    // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
    KS_INTERLACE_UNUSED = $00000008;
    KS_INTERLACE_FieldPatternMask = $00000030;  // use this mask with AMINTERLACE_FieldPat*
    KS_INTERLACE_FieldPatField1Only = $00000000;  // Data never contains a Field2
    KS_INTERLACE_FieldPatField2Only = $00000010;  // Data never contains a Field1
    KS_INTERLACE_FieldPatBothRegular = $00000020;  // There will be a Field2 for every Field1 (required for Weave?)
    KS_INTERLACE_FieldPatBothIrregular = $00000030;  // Random pattern of Field1s and Field2s
    KS_INTERLACE_DisplayModeMask = $000000c0;
    KS_INTERLACE_DisplayModeBobOnly = $00000000;
    KS_INTERLACE_DisplayModeWeaveOnly = $00000040;
    KS_INTERLACE_DisplayModeBobOrWeave = $00000080;

    KS_COPYPROTECT_RestrictDuplication = $00000001;  // duplication of this stream should be restricted

    KS_MPEG2_DoPanScan = $00000001; //if set, the MPEG-2 video decoder should crop output image
    //  based on pan-scan vectors in picture_display_extension
    //  and change the picture aspect ratio accordingly.
    KS_MPEG2_DVDLine21Field1 = $00000002;  //if set, the MPEG-2 decoder must be able to produce an output
    //  pin for DVD style closed caption data found in GOP layer of field 1
    KS_MPEG2_DVDLine21Field2 = $00000004;  //if set, the MPEG-2 decoder must be able to produce an output
    //  pin for DVD style closed caption data found in GOP layer of field 2
    KS_MPEG2_SourceIsLetterboxed = $00000008;  //if set, indicates that black bars have been encoded in the top
    //  and bottom of the video.
    KS_MPEG2_FilmCameraMode = $00000010;  //if set, indicates "film mode" used for 625/50 content.  If cleared,
    //  indicates that "camera mode" was used.
    KS_MPEG2_LetterboxAnalogOut = $00000020;  //if set and this stream is sent to an analog output, it should
    //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
    KS_MPEG2_DSS_UserData = $00000040;  //if set, the MPEG-2 decoder must process DSS style user data
    KS_MPEG2_DVB_UserData = $00000080;  //if set, the MPEG-2 decoder must process DVB style user data
    KS_MPEG2_27MhzTimebase = $00000100;  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}

    KS_MPEG2_WidescreenAnalogOut = $00000200;  //if set and this stream is sent to an analog output, it should
    //  be in widescreen format (4x3 content should be centered on a 16x9 output).
    //  Streams sent to VGA should be widescreened only by renderers.

    KS_AMCONTROL_USED = $00000001;
    // Used to test if these flags are supported.  Set and test for AcceptMediaType.
    // If rejected, then you cannot use the AMCONTROL flags (send 0 for dwReserved1)
    KS_AMCONTROL_PAD_TO_4x3 = $00000002;// if set means display the image in a 4x3 area
    KS_AMCONTROL_PAD_TO_16x9 = $00000004; // if set means display the image in a 16x9 area
    KS_AMCONTROL_COLORINFO_PRESENT = $00000080;
    // if set, indicates DXVA color info is present in the upper (24) bits of the dwControlFlags

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    KS_MAX_SIZE_MPEG1_SEQUENCE_INFO = 140;

    //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz
    KS_MPEGAUDIOINFO_27MhzTimebase = $00000001;



    //===========================================================================
    // StreamDescriptionFlags

    // These define the "purpose" of each video stream
    //===========================================================================

    KS_VIDEOSTREAM_PREVIEW = $0001; // Preview stream
    KS_VIDEOSTREAM_CAPTURE = $0002;  // Capture stream
    KS_VIDEOSTREAM_VBI = $0010;  // Field1 VBI
    KS_VIDEOSTREAM_NABTS = $0020;  // Field1 NABTS
    KS_VIDEOSTREAM_CC = $0100;  // Closed Captioning
    KS_VIDEOSTREAM_EDS = $0200;  // Extended Data Services
    KS_VIDEOSTREAM_TELETEXT = $0400;  // Field1 Teletext only
    KS_VIDEOSTREAM_STILL = $1000;  // Still image input
    KS_VIDEOSTREAM_IS_VPE = $8000;  // Is a VPE based stream?

    // MemoryAllocationFlags
    KS_VIDEO_ALLOC_VPE_SYSTEM = $0001;  // VPE surface in system memory
    KS_VIDEO_ALLOC_VPE_DISPLAY = $0002;  // VPE surface in display memory
    KS_VIDEO_ALLOC_VPE_AGP = $0004;  // VPE surface in AGP memory


    KS_VBICAP_PROTECTION_MV_PRESENT = $0001;
    KS_VBICAP_PROTECTION_MV_HARDWARE = $0002;
    KS_VBICAP_PROTECTION_MV_DETECTED = $0004;

    ///////////////////////////////////////////////////////////////////////////////////////
    // IP/NABTS Protocol Reserved Group IDs - Overall Range $800-$8FF [Decimal 2048-2079]
    // Intervening values(0-F) are used if there are multiple providers at a particular tier
    ///////////////////////////////////////////////////////////////////////////////////////

    // Used by individual content creators in show footage/data
    KS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE = $800;
    KS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE = $810;

    // Used by production company in finished show data
    KS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE = $820;
    KS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE = $830;

    // Used by broadcast syndicates in syndicated show data
    KS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE = $840;
    KS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE = $850;

    // Used by tv networks in network television data
    KS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE = $860;
    KS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE = $870;

    // Used by telvision stations in local programming data
    KS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE = $880;
    KS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE = $890;

    // Used by cable system in cable head-end originated data
    KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE = $8A0;
    KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE = $8B0;

    // The values between $8C0 - $8EF are reserved for future expansion

    // Used by Microsoft for Testing purposes ($8F0 - $8FF)
    KS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE = $8F0;


    //////////////////////////////////////////////////////////////
    // NABTS Bundle data structure definition
    //////////////////////////////////////////////////////////////

    MAX_NABTS_VBI_LINES_PER_FIELD = 11;
    NABTS_LINES_PER_BUNDLE = 16;
    NABTS_PAYLOAD_PER_LINE = 28;
    NABTS_BYTES_PER_LINE = 36;


    // These KS_CC_SUBSTREAM_* bitmasks are used with VBICODECFILTERING_CC_SUBSTREAMS
    KS_CC_SUBSTREAM_ODD = $0001; // Unfiltered Field 1 Data
    KS_CC_SUBSTREAM_EVEN = $0002; // Unfiltered Field 2 Data


    // The following flags describe CC field 1 substreams: CC1,CC2,TT1,TT2
    KS_CC_SUBSTREAM_FIELD1_MASK = $00F0;
    KS_CC_SUBSTREAM_SERVICE_CC1 = $0010;
    KS_CC_SUBSTREAM_SERVICE_CC2 = $0020;
    KS_CC_SUBSTREAM_SERVICE_T1 = $0040;
    KS_CC_SUBSTREAM_SERVICE_T2 = $0080;

    // The following flags describe CC field 2 substreams: CC3,CC4,TT3,TT4,XDS
    KS_CC_SUBSTREAM_FIELD2_MASK = $1F00;
    KS_CC_SUBSTREAM_SERVICE_CC3 = $0100;
    KS_CC_SUBSTREAM_SERVICE_CC4 = $0200;
    KS_CC_SUBSTREAM_SERVICE_T3 = $0400;
    KS_CC_SUBSTREAM_SERVICE_T4 = $0800;
    KS_CC_SUBSTREAM_SERVICE_XDS = $1000;

    // Special Note: field 1 or 2 substreams are usually on found on field 1 and 2 respectively
    // If the VBI odd/even polarity is reversed, the correct filtered data will still be found.

    ///////////////////////////////////////////////////////////////////
    // Hardware decoded CC stream format
    ///////////////////////////////////////////////////////////////////

    CC_MAX_HW_DECODE_LINES = 12;


    //////////////////////////////////////////////////////////////
    // WST Codec Teletext Media Sample Format
    //////////////////////////////////////////////////////////////

    WST_TVTUNER_CHANGE_BEGIN_TUNE = $1000;  // Starting a tuning operation
    WST_TVTUNER_CHANGE_END_TUNE = $2000;  // Ending a tuning operation

    MAX_WST_VBI_LINES_PER_FIELD = 17;
    WST_BYTES_PER_LINE = 42;

    NABTS_BUFFER_PICTURENUMBER_SUPPORT = 1;

    //===========================================================================
    // KSSTREAM_HEADER extensions for digital video
    //===========================================================================

    KS_VIDEO_FLAG_FIELD_MASK = $0003;        // Frame or Field (default is frame)
    KS_VIDEO_FLAG_FRAME = $0000;        // Frame or Field (default is frame)
    KS_VIDEO_FLAG_FIELD1 = $0001;
    KS_VIDEO_FLAG_FIELD2 = $0002;
    KS_VIDEO_FLAG_FIELD1FIRST = $0004;
    KS_VIDEO_FLAG_WEAVE = $0008;

    KS_VIDEO_FLAG_IPB_MASK = $0030;        // I, B, or P (default is I)
    KS_VIDEO_FLAG_I_FRAME = $0000;        // I, B, or P (default is I)
    KS_VIDEO_FLAG_P_FRAME = $0010;
    KS_VIDEO_FLAG_B_FRAME = $0020;
    KS_VIDEO_FLAG_REPEAT_FIELD = $0040;


    //===========================================================================
    // KSSTREAM_HEADER extensions for VBI
    //===========================================================================

    //{$if (NTDDI_VERSION < NTDDI_WINXP)}
    KS_VBI_FLAG_FRAME = $0000; // Frame or Field (default is frame)
    //{$ENDIF}
    KS_VBI_FLAG_FIELD1 = $0001;
    KS_VBI_FLAG_FIELD2 = $0002;

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KS_VBI_FLAG_MV_PRESENT = $0100;
    KS_VBI_FLAG_MV_HARDWARE = $0200;
    KS_VBI_FLAG_MV_DETECTED = $0400;
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    KS_VBI_FLAG_TVTUNER_CHANGE = $0010; // TvTunerChangeInfo is valid
    KS_VBI_FLAG_VBIINFOHEADER_CHANGE = $0020; // VBIInfoHeader is valid


    KS_AnalogVideo_NTSC_Mask = $00000007;
{$if (NTDDI_VERSION >= NTDDI_WINXP)}
    KS_AnalogVideo_PAL_Mask = $00100FF0;
{$ELSE}
    KS_AnalogVideo_PAL_Mask = $00000FF0;
{$ENDIF}
    KS_AnalogVideo_SECAM_Mask = $000FF000;

    KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO = $0001;
    KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL = $0002;

    KSPROPERTY_CAMERACONTROL_FLAGS_AUTO = $0001;
    KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL = $0002;
    //{$if (NTDDI_VERSION >= NTDDI_WIN8)}
    KSPROPERTY_CAMERACONTROL_FLAGS_ASYNCHRONOUS = $0004;
    //{$ENDIF}

    KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE = $0000;
    KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE = $0010;

    KSPROPERTY_CAMERACONTROL_FLASH_OFF = $00000000;
    KSPROPERTY_CAMERACONTROL_FLASH_ON = $00000001;
    KSPROPERTY_CAMERACONTROL_FLASH_AUTO = $00000002;

    KSPROPERTY_CAMERACONTROL_FLASH_FLAGS_AUTO = $00000001;
    KSPROPERTY_CAMERACONTROL_FLASH_FLAGS_MANUAL = $00000002;


    KSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_OFF = $00000000;
    KSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_HIGH = $00000001;
    KSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_MEDIUM = $00000002;
    KSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_LOW = $00000003;
    KSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_AUTO = $00000004;

    KSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_FLAGS_AUTO = $00000001;
    KSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_FLAGS_MANUAL = $00000002;

    KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_FLAGS_AUTO = $00000001;
    KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_FLAGS_MANUAL = $00000002;
    KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_FLAGS_ASYNC = $80000000;
    KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_CONFIG_FOCUS = $00000100;
    KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_CONFIG_EXPOSURE = $00000200;
    KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_CONFIG_WB = $00000400;
    KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_CONVERGEMODE = $40000000;

    KSPROPERTY_CAMERACONTROL_IMAGE_PIN_CAPABILITY_EXCLUSIVE_WITH_RECORD = $00000001;
    KSPROPERTY_CAMERACONTROL_IMAGE_PIN_CAPABILITY_SEQUENCE_EXCLUSIVE_WITH_RECORD = $00000002;

    KSCAMERA_EXTENDEDPROP_FILTERSCOPE = $FFFFFFFF;

    //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)}
    KSCAMERA_EXTENDEDPROP_CAPS_RESERVED = $FF00000000000000;
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)


    KSCAMERA_EXTENDEDPROP_CAPS_ASYNCCONTROL = $8000000000000000;
    KSCAMERA_EXTENDEDPROP_CAPS_CANCELLABLE = $4000000000000000;

    KSCAMERA_EXTENDEDPROP_FLAG_CANCELOPERATION = $8000000000000000;

    // This mask represents the reserved bits for all capability flags.  All EXTENDEDPROP capability
    // flags defined below must NOT use the upper 8 bits.
    // Same applies to the flags.
    KSCAMERA_EXTENDEDPROP_CAPS_MASK = $FF00000000000000;
    KSCAMERA_EXTENDEDPROP_FLAG_MASK = $FF00000000000000;

    KSCAMERA_EXTENDEDPROP_PHOTOMODE_NORMAL = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_PHOTOMODE_SEQUENCE = $0000000000000001;

    KSCAMERA_EXTENDEDPROP_WARMSTART_MODE_DISABLED = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_WARMSTART_MODE_ENABLED = $0000000000000001;

    KSCAMERA_EXTENDEDPROP_PHOTOTHUMBNAIL_DISABLE = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_PHOTOTHUMBNAIL_2X = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_PHOTOTHUMBNAIL_4X = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_PHOTOTHUMBNAIL_8X = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_PHOTOTHUMBNAIL_16X = $0000000000000008;

    KSCAMERA_EXTENDEDPROP_SCENEMODE_AUTO = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_MACRO = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_PORTRAIT = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_SPORT = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_SNOW = $0000000000000008;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_NIGHT = $0000000000000010;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_BEACH = $0000000000000020;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_SUNSET = $0000000000000040;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_CANDLELIGHT = $0000000000000080;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_LANDSCAPE = $0000000000000100;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_NIGHTPORTRAIT = $0000000000000200;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_BACKLIT = $0000000000000400;
    KSCAMERA_EXTENDEDPROP_SCENEMODE_MANUAL = $0080000000000000;

    KSCAMERA_EXTENDEDPROP_VIDEOTORCH_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_VIDEOTORCH_ON = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_VIDEOTORCH_ON_ADJUSTABLEPOWER = $0000000000000002;

    KSCAMERA_EXTENDEDPROP_FLASH_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_FLASH_ON = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_FLASH_ON_ADJUSTABLEPOWER = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_FLASH_AUTO = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_FLASH_AUTO_ADJUSTABLEPOWER = $0000000000000008;
    KSCAMERA_EXTENDEDPROP_FLASH_REDEYEREDUCTION = $0000000000000010;
    KSCAMERA_EXTENDEDPROP_FLASH_SINGLEFLASH = $0000000000000020;
    KSCAMERA_EXTENDEDPROP_FLASH_MULTIFLASHSUPPORTED = $0000000000000040;
    KSCAMERA_EXTENDEDPROP_FLASH_MODE_MASK =
        (KSCAMERA_EXTENDEDPROP_FLASH_ON or KSCAMERA_EXTENDEDPROP_FLASH_ON_ADJUSTABLEPOWER or
        KSCAMERA_EXTENDEDPROP_FLASH_AUTO or KSCAMERA_EXTENDEDPROP_FLASH_AUTO_ADJUSTABLEPOWER);


    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_PHOTO = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_VIDEO = $0000000000000002;

    //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}

    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_DEFAULT = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_QUALITY = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_LATENCY = $0000000000000008;
    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_POWER = $0000000000000010;

    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_PERF_MASK =
        (KSCAMERA_EXTENDEDPROP_OPTIMIZATION_QUALITY or KSCAMERA_EXTENDEDPROP_OPTIMIZATION_LATENCY or
        KSCAMERA_EXTENDEDPROP_OPTIMIZATION_POWER);

    KSCAMERA_EXTENDEDPROP_OPTIMIZATION_PRIMARYUSE_MASK =
        (KSCAMERA_EXTENDEDPROP_OPTIMIZATION_PHOTO or KSCAMERA_EXTENDEDPROP_OPTIMIZATION_VIDEO);

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

    KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_AUTO = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_MANUAL = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_LOCK = $0000000000000004;

    // This combines the generic Video Proc bits shared by all video proc controls.
    KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_MASK =
        (KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_AUTO or KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_MANUAL or
        KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_LOCK);


    KSCAMERA_EXTENDEDPROP_FOCUS_CONTINUOUS = $0000000000000100;

    // Focus control extends the generic video proc mask by adding the continous flag.
    KSCAMERA_EXTENDEDPROP_FOCUS_MODE_MASK =
        (KSCAMERA_EXTENDEDPROP_VIDEOPROCFLAG_MASK or KSCAMERA_EXTENDEDPROP_FOCUS_CONTINUOUS);

    KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_MACRO = $0000000000010000;
    KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_NORMAL = $0000000000020000;
    KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_FULLRANGE = $0000000000040000;
    KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_INFINITY = $0000000000080000;
    KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_HYPERFOCAL = $0000000000100000;
    KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_MASK =
        (KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_MACRO or KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_NORMAL or
        KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_FULLRANGE or KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_INFINITY or
        KSCAMERA_EXTENDEDPROP_FOCUS_RANGE_HYPERFOCAL);


    //{$if (NTDDI_VERSION >= NTDDI_WINBLUE}

    // Spare bits $200000 - $800000 in case of future range expansion
    KSCAMERA_EXTENDEDPROP_FOCUS_DISTANCE_INFINITY = $0000000001000000;
    KSCAMERA_EXTENDEDPROP_FOCUS_DISTANCE_HYPERFOCAL = $0000000002000000;
    KSCAMERA_EXTENDEDPROP_FOCUS_DISTANCE_NEAREST = $0000000004000000;
    KSCAMERA_EXTENDEDPROP_FOCUS_DISTANCE_MASK =
        (KSCAMERA_EXTENDEDPROP_FOCUS_DISTANCE_INFINITY or KSCAMERA_EXTENDEDPROP_FOCUS_DISTANCE_HYPERFOCAL or
        KSCAMERA_EXTENDEDPROP_FOCUS_DISTANCE_NEAREST);
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)



    KSCAMERA_EXTENDEDPROP_ISO_AUTO = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_ISO_50 = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_ISO_80 = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_ISO_100 = $0000000000000008;
    KSCAMERA_EXTENDEDPROP_ISO_200 = $0000000000000010;
    KSCAMERA_EXTENDEDPROP_ISO_400 = $0000000000000020;
    KSCAMERA_EXTENDEDPROP_ISO_800 = $0000000000000040;
    KSCAMERA_EXTENDEDPROP_ISO_1600 = $0000000000000080;
    KSCAMERA_EXTENDEDPROP_ISO_3200 = $0000000000000100;
    KSCAMERA_EXTENDEDPROP_ISO_6400 = $0000000000000200;
    KSCAMERA_EXTENDEDPROP_ISO_12800 = $0000000000000400;
    KSCAMERA_EXTENDEDPROP_ISO_25600 = $0000000000000800;


    //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)}

    KSCAMERA_EXTENDEDPROP_FOCUS_CONTINUOUSLOCK = $0000000000000200;
    KSCAMERA_EXTENDEDPROP_FOCUS_UNLOCK = $0000000000000400;
    KSCAMERA_EXTENDEDPROP_FOCUS_DRIVERFALLBACK_OFF = $0000000000000800;
    KSCAMERA_EXTENDEDPROP_FOCUS_REGIONBASED = $0000000000001000;

    KSCAMERA_EXTENDEDPROP_FOCUS_MODE_ADVANCED_MASK =
        (KSCAMERA_EXTENDEDPROP_FOCUS_CONTINUOUSLOCK or KSCAMERA_EXTENDEDPROP_FOCUS_UNLOCK or
        KSCAMERA_EXTENDEDPROP_FOCUS_DRIVERFALLBACK_OFF or KSCAMERA_EXTENDEDPROP_FOCUS_REGIONBASED);

    KSCAMERA_EXTENDEDPROP_ISO_MANUAL = $0080000000000000;

    KSCAMERA_EXTENDEDPROP_FLASH_ASSISTANT_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_FLASH_ASSISTANT_ON = $0000000000000080;
    KSCAMERA_EXTENDEDPROP_FLASH_ASSISTANT_AUTO = $0000000000000100;
    KSCAMERA_EXTENDEDPROP_FLASH_ASSISTANT_MASK =
        (KSCAMERA_EXTENDEDPROP_FLASH_ASSISTANT_ON or KSCAMERA_EXTENDEDPROP_FLASH_ASSISTANT_AUTO);

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)

    KSCAMERA_EXTENDEDPROP_EVCOMP_SIXTHSTEP = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_EVCOMP_QUARTERSTEP = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_EVCOMP_THIRDSTEP = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_EVCOMP_HALFSTEP = $0000000000000008;
    KSCAMERA_EXTENDEDPROP_EVCOMP_FULLSTEP = $0000000000000010;

    //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)

    KSCAMERA_EXTENDEDPROP_PHOTOMODE_SEQUENCE_SUB_NONE = $00000000;
    KSCAMERA_EXTENDEDPROP_PHOTOMODE_SEQUENCE_SUB_VARIABLE = $00000001;

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)

    KSCAMERA_EXTENDEDPROP_METADATA_MEMORYTYPE_MASK = $00000000000000FF;

    KSCAMERA_EXTENDEDPROP_METADATA_SYSTEMMEMORY = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_METADATA_ALIGNMENTREQUIRED = $0000000000000100;

    KSCAMERA_METADATA_FRAMEILLUMINATION_FLAG_ON = $00000001;

    KSCAMERA_METADATA_CAPTURESTATS_FLAG_EXPOSURETIME = $00000001;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_EXPOSURECOMPENSATION = $00000002;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_ISOSPEED = $00000004;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_FOCUSSTATE = $00000008;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_LENSPOSITION = $00000010;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_WHITEBALANCE = $00000020;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_FLASH = $00000040;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_FLASHPOWER = $00000080;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_ZOOMFACTOR = $00000100;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_SCENEMODE = $00000200;
    KSCAMERA_METADATA_CAPTURESTATS_FLAG_SENSORFRAMERATE = $00000400;


    // Focus Priority
    KSCAMERA_EXTENDEDPROP_FOCUSPRIORITY_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_FOCUSPRIORITY_ON = $0000000000000001;

    // Photo confirmation (aka still confirmation)
    KSCAMERA_EXTENDEDPROP_PHOTOCONFIRMATION_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_PHOTOCONFIRMATION_ON = $0000000000000001;

    KSCAMERA_PERFRAMESETTING_AUTO = $0000000100000000;
    KSCAMERA_PERFRAMESETTING_MANUAL = $0000000200000000;



    //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}
    KSCAMERA_EXTENDEDPROP_VIDEOSTABILIZATION_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_VIDEOSTABILIZATION_ON = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_VIDEOSTABILIZATION_AUTO = $0000000000000002;

    KSCAMERA_EXTENDEDPROP_VFR_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_VFR_ON = $0000000000000001;

    KSCAMERA_EXTENDEDPROP_FACEDETECTION_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_FACEDETECTION_ON = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_FACEDETECTION_PREVIEW = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_FACEDETECTION_VIDEO = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_FACEDETECTION_PHOTO = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_FACEDETECTION_BLINK = $0000000000000008;
    KSCAMERA_EXTENDEDPROP_FACEDETECTION_SMILE = $0000000000000010;

    KSCAMERA_EXTENDEDPROP_FACEDETECTION_MASK =
        (KSCAMERA_EXTENDEDPROP_FACEDETECTION_PREVIEW or KSCAMERA_EXTENDEDPROP_FACEDETECTION_VIDEO or
        KSCAMERA_EXTENDEDPROP_FACEDETECTION_PHOTO);

    KSCAMERA_EXTENDEDPROP_FACEDETECTION_ADVANCED_MASK =
        (KSCAMERA_EXTENDEDPROP_FACEDETECTION_BLINK or KSCAMERA_EXTENDEDPROP_FACEDETECTION_SMILE);




    KSCAMERA_EXTENDEDPROP_VIDEOHDR_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_VIDEOHDR_ON = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_VIDEOHDR_AUTO = $0000000000000002;

    KSCAMERA_EXTENDEDPROP_HISTOGRAM_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_HISTOGRAM_ON = $0000000000000001;

    KSCAMERA_EXTENDEDPROP_OIS_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_OIS_ON = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_OIS_AUTO = $0000000000000002;

    KSCAMERA_EXTENDEDPROP_ADVANCEDPHOTO_OFF = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_ADVANCEDPHOTO_AUTO = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_ADVANCEDPHOTO_HDR = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_ADVANCEDPHOTO_FNF = $0000000000000004;
    KSCAMERA_EXTENDEDPROP_ADVANCEDPHOTO_ULTRALOWLIGHT = $0000000000000008;

    KSCAMERA_EXTENDEDPROP_ZOOM_DEFAULT = $0000000000000000;
    KSCAMERA_EXTENDEDPROP_ZOOM_DIRECT = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_ZOOM_SMOOTH = $0000000000000002;

    KSCAMERA_EXTENDEDPROP_FACEAUTH_MODE_DISABLED = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_FACEAUTH_MODE_ALTERNATIVE_FRAME_ILLUMINATION = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_FACEAUTH_MODE_BACKGROUND_SUBTRACTION = $0000000000000004;

    KSCAMERA_EXTENDEDPROP_SECUREMODE_DISABLED = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_SECUREMODE_ENABLED = $0000000000000002;

    KSCAMERA_EXTENDEDPROP_VIDEOTEMPORALDENOISING_AUTO = $0000000000000001;
    KSCAMERA_EXTENDEDPROP_VIDEOTEMPORALDENOISING_OFF = $0000000000000002;
    KSCAMERA_EXTENDEDPROP_VIDEOTEMPORALDENOISING_ON = $0000000000000004;



    KSCAMERAPROFILE_FLAGS_VIDEOSTABLIZATION = $0000000000000001;
    KSCAMERAPROFILE_FLAGS_VIDEOHDR = $0000000000000002;
    KSCAMERAPROFILE_FLAGS_PHOTOHDR = $0000000000000004;
    KSCAMERAPROFILE_FLAGS_FACEDETECTION = $0000000000000008;
    KSCAMERAPROFILE_FLAGS_VARIABLEPHOTOSEQUENCE = $0000000000000010;
    KSCAMERAPROFILE_FLAGS_PREVIEW_RES_MUSTMATCH = $0000000000000020;

    KSDEVICE_PROFILE_TYPE_UNKNOWN = $00000000;
    KSDEVICE_PROFILE_TYPE_CAMERA = $00000001;


    // Camera Pin Sensor output type should be in sync with MFFrameSourceTypes

    KSCameraProfileSensorType_RGB = $0001;
    KSCameraProfileSensorType_Infrared = $0002;
    KSCameraProfileSensorType_Depth = $0004;
    KSCameraProfileSensorType_PoseTracking = $0008;
    KSCameraProfileSensorType_ImageSegmentation = $0010;
    KSCameraProfileSensorType_Custom = $0080;

    KS_TVAUDIO_MODE_MONO = $0001;         // Mono
    KS_TVAUDIO_MODE_STEREO = $0002;         // Stereo
    KS_TVAUDIO_MODE_LANG_A = $0010;         // Primary language
    KS_TVAUDIO_MODE_LANG_B = $0020;         // 2nd avail language
    KS_TVAUDIO_MODE_LANG_C = $0040;         // 3rd avail language
    //{$if (NTDDI_VERSION >= NTDDI_VISTA)}
    KS_TVAUDIO_PRESET_STEREO = $0200;         // if present, stereo
    KS_TVAUDIO_PRESET_LANG_A = $1000;        // if present, Language A
    KS_TVAUDIO_PRESET_LANG_B = $2000;        // if present, Language B
    KS_TVAUDIO_PRESET_LANG_C = $4000;        // if present, Language C
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_VISTA

    DDPF_FOURCC = $00000004;

    KS_AM_UseNewCSSKey = $0001;

    MAX_SINK_DESCRIPTION_NAME_LENGTH = 32;
    JACKDESC2_PRESENCE_DETECT_CAPABILITY = $00000001;
    JACKDESC2_DYNAMIC_FORMAT_CHANGE_CAPABILITY = $00000002;

    // define new property id
    KSPROPERTY_AUDIO_BUFFER_DURATION = 1;

    AUDIOMODULE_MAX_DATA_SIZE = 64000;
    AUDIOMODULE_MAX_NAME_CCH_SIZE = 128;

type
    TKSMULTIPLE_DATA_PROP = record
        _Property: TKSPROPERTY;
        MultipleItem: TKSMULTIPLE_ITEM;
    end;

    PKSMULTIPLE_DATA_PROP = ^TKSMULTIPLE_DATA_PROP;

    KSINTERFACE_MEDIA = (
        KSINTERFACE_MEDIA_MUSIC, // Reserved for system use
        KSINTERFACE_MEDIA_WAVE_BUFFERED, // Reserved for system use
        KSINTERFACE_MEDIA_WAVE_QUEUED);
{$Z1}
{$A1}
    // include <pshpack1.h>

    // Convenient wrapper structure for the case in which the WaveFormatEx is
    // known not to contain extra data.
    TKSDATAFORMAT_WAVEFORMATEX = packed record
        DataFormat: TKSDATAFORMAT;
        WAVEFORMATEX: TWAVEFORMATEX;
    end;

    PKSDATAFORMAT_WAVEFORMATEX = ^TKSDATAFORMAT_WAVEFORMATEX;

    TWAVEFORMATEXTENSIBLE = packed record
        Format: TWAVEFORMATEX;
        Samples: record
            case integer of
                0: (wValidBitsPerSample: word); (* bits of precision *)
                1: (wSamplesPerBlock: word); (* valid if wBitsPerSample==0 *)
                2: (wReserved: word) (* If neither applies, set to zero. *)
        end;

        dwChannelMask: DWORD; (* which channels are *)
        (* present in stream *)
        SubFormat: TGUID;
    end;

    PWAVEFORMATEXTENSIBLE = ^TWAVEFORMATEXTENSIBLE;

    TWAVEFORMATEXTENSIBLE_IEC61937 = packed record
        FormatExt: TWAVEFORMATEXTENSIBLE; (* Format of encoded data as it is *)
        (* intended to be streamed over the link *)
        dwEncodedSamplesPerSec: DWORD; (* Sampling rate of the post-decode audio. *)
        dwEncodedChannelCount: DWORD; (* Channel count of the post-decode audio. *)
        dwAverageBytesPerSec: DWORD; (* Byte rate of the content, can be 0. *)
    end;

    PWAVEFORMATEXTENSIBLE_IEC61937 = ^TWAVEFORMATEXTENSIBLE_IEC61937;

    // Convenient wrapper structure for the case in which the WaveFormatExt is
    // known not to contain extra data.
    TKSDATAFORMAT_WAVEFORMATEXTENSIBLE = packed record
        DataFormat: TKSDATAFORMAT;
        WaveFormatExt: TWAVEFORMATEXTENSIBLE;
    end;

    PKSDATAFORMAT_WAVEFORMATEXTENSIBLE = ^TKSDATAFORMAT_WAVEFORMATEXTENSIBLE;

    // DirectSound buffer description
    TKSDSOUND_BUFFERDESC = packed record
        Flags: ULONG;
        Control: ULONG;
        WAVEFORMATEX: TWAVEFORMATEX;
    end;

    PKSDSOUND_BUFFERDESC = ^TKSDSOUND_BUFFERDESC;

    // DirectSound format
    TKSDATAFORMAT_DSOUND = packed record
        DataFormat: TKSDATAFORMAT;
        BufferDesc: TKSDSOUND_BUFFERDESC;
    end;

    PKSDATAFORMAT_DSOUND = ^TKSDATAFORMAT_DSOUND;

    // include <poppack.h>
{$A4}
{$Z4}

    TKSAUDIO_POSITION = record
{$if defined(_NTDDK_)}
        PlayOffset: ULONGLONG;
        WriteOffset: ULONGLONG;
{$ELSE} // !_NTDDK_
        PlayOffset: DWORDLONG;
        WriteOffset: DWORDLONG;
{$ENDIF}// !_NTDDK_
    end;
    PKSAUDIO_POSITION = ^TKSAUDIO_POSITION;

    //The KSAUDIO_PRESENTATION_POSITION structure specifies the current positions of audio data being rendered to the KS pin instance.
    TKSAUDIO_PRESENTATION_POSITION = record
        u64PositionInBlocks: UINT64;
        // The block offset from the start of the stream to the current post-decoded uncompressed
        // position in the stream, where a block is the group of channels in the same sample; for a PCM stream,
        // a block is same as a frame. For compressed formats, a block is a single sample within a frame
        // (eg. each MP3 frame has 1152 samples or 1152 blocks)
        u64QPCPosition: UINT64;
        // The value of the performance counter at the time that the audio endpoint device read the device
        // position (*pu64Position) in response to the KSAUDIO_PRESENTATION_POSITION call.
    end;
    PKSAUDIO_PRESENTATION_POSITION = ^TKSAUDIO_PRESENTATION_POSITION;


    TCONSTRICTOR_OPTION = (
        CONSTRICTOR_OPTION_DISABLE = 0,
        CONSTRICTOR_OPTION_MUTE);

    // {$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
    TKSAUDIO_PACKETSIZE_PROCESSINGMODE_CONSTRAINT = record
        ProcessingMode: TGUID;
        SamplesPerProcessingPacket: ULONG;
        ProcessingPacketDurationInHns: ULONG;
    end;

    PKSAUDIO_PACKETSIZE_PROCESSINGMODE_CONSTRAINT = ^TKSAUDIO_PACKETSIZE_PROCESSINGMODE_CONSTRAINT;

    TKSAUDIO_PACKETSIZE_CONSTRAINTS = record
        MinPacketPeriodInHns: ULONG;
        PacketSizeFileAlignment: ULONG;
        Reserved: ULONG;
        NumProcessingModeConstraints: ULONG;
        ProcessingModeConstraints {NumProcessingModeConstraints}: PKSAUDIO_PACKETSIZE_PROCESSINGMODE_CONSTRAINT;
    end;
    // {$ENDIF}

    // {$if (NTDDI_VERSION >= NTDDI_WIN10_RS1)
    TKSAUDIO_PACKETSIZE_CONSTRAINTS2 = record
        MinPacketPeriodInHns: ULONG;
        PacketSizeFileAlignment: ULONG;
        MaxPacketSizeInBytes: ULONG;
        NumProcessingModeConstraints: ULONG;
        ProcessingModeConstraints{NumProcessingModeConstraints}: PKSAUDIO_PACKETSIZE_PROCESSINGMODE_CONSTRAINT;
    end;
    // {$ENDIF}


    //===========================================================================
    // Microphone array pin descriptor

    // {$if (NTDDI_VERSION >= NTDDI_VISTA)
    TKSMICARRAY_MICTYPE = (
        KSMICARRAY_MICTYPE_OMNIDIRECTIONAL,
        KSMICARRAY_MICTYPE_SUBCARDIOID,
        KSMICARRAY_MICTYPE_CARDIOID,
        KSMICARRAY_MICTYPE_SUPERCARDIOID,
        KSMICARRAY_MICTYPE_HYPERCARDIOID,
        KSMICARRAY_MICTYPE_8SHAPED,
        KSMICARRAY_MICTYPE_VENDORDEFINED = $0F);

    TKSAUDIO_MICROPHONE_COORDINATES = record
        usType: USHORT;           // Type of Microphone
        wXCoord: SHORT;          // X Coordinate of Mic
        wYCoord: SHORT;          // Y Coordinate of Mic
        wZCoord: SHORT;          // Z Coordinate of Mic
        wVerticalAngle: SHORT;   // MRA Vertical Angle
        wHorizontalAngle: SHORT; // MRA Horizontal Angle
    end;
    PKSAUDIO_MICROPHONE_COORDINATES = ^TKSAUDIO_MICROPHONE_COORDINATES;

    TKSMICARRAY_MICARRAYTYPE = (
        KSMICARRAY_MICARRAYTYPE_LINEAR,
        KSMICARRAY_MICARRAYTYPE_PLANAR,
        KSMICARRAY_MICARRAYTYPE_3D);

    TKSAUDIO_MIC_ARRAY_GEOMETRY = record
        usVersion: USHORT;             // Version of Mic array specification ($0100)
        usMicArrayType: USHORT;        // Type of Mic Array
        wVerticalAngleBegin: SHORT;   // Work Volume Vertical Angle Begin
        wVerticalAngleEnd: SHORT;     // Work Volume Vertical Angle End
        wHorizontalAngleBegin: SHORT; // Work Volume HorizontalAngle Begin
        wHorizontalAngleEnd: SHORT;   // Work Volume HorizontalAngle End
        usFrequencyBandLo: USHORT;     // Low end of Freq Range
        usFrequencyBandHi: USHORT;     // High end of Freq Range

        usNumberOfMicrophones: USHORT;  // Count of microphone
        // coordinate structures
        // to follow.

        KsMicCoord: PKSAUDIO_MICROPHONE_COORDINATES; // Array of Microphone
        // Coordinate structures
    end;
    PKSAUDIO_MIC_ARRAY_GEOMETRY = ^TKSAUDIO_MIC_ARRAY_GEOMETRY;

    // {$ENDIF} // (NTDDI_VERSION >= NTDDI_VISTA)

    //===========================================================================
    // DirectSound3D HAL


    TDS3DVECTOR = record
        case integer of
            0: (x: single;
                y: single;
                z: single);
            1: (
                dvX: single;
                dvY: single;
                dvZ: single);
    end;
    PDS3DVECTOR = ^TDS3DVECTOR;


    TKSPROPERTY_DIRECTSOUND3DLISTENER = (
        KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
        KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
        KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
        KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
        KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
        KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
        KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
        KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
        KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION);

    TKSDS3D_LISTENER_ALL = record
        Position: TDS3DVECTOR;
        Velocity: TDS3DVECTOR;
        OrientFront: TDS3DVECTOR;
        OrientTop: TDS3DVECTOR;
        DistanceFactor: single;
        RolloffFactor: single;
        DopplerFactor: single;
    end;
    PKSDS3D_LISTENER_ALL = ^TKSDS3D_LISTENER_ALL;

    TKSDS3D_LISTENER_ORIENTATION = record
        Front: TDS3DVECTOR;
        Top: TDS3DVECTOR;
    end;
    PKSDS3D_LISTENER_ORIENTATION = ^TKSDS3D_LISTENER_ORIENTATION;



    TKSPROPERTY_DIRECTSOUND3DBUFFER = (
        KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
        KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
        KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
        KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
        KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
        KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
        KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
        KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
        KSPROPERTY_DIRECTSOUND3DBUFFER_MODE);


    TKSDS3D_BUFFER_ALL = record
        Position: TDS3DVECTOR;
        Velocity: TDS3DVECTOR;
        InsideConeAngle: ULONG;
        OutsideConeAngle: ULONG;
        ConeOrientation: TDS3DVECTOR;
        ConeOutsideVolume: LONG;
        MinDistance: single;
        MaxDistance: single;
        Mode: ULONG;
    end;
    PKSDS3D_BUFFER_ALL = ^TKSDS3D_BUFFER_ALL;

    TKSDS3D_BUFFER_CONE_ANGLES = record
        InsideConeAngle: ULONG;
        OutsideConeAngle: ULONG;
    end;
    PKSDS3D_BUFFER_CONE_ANGLES = ^TKSDS3D_BUFFER_CONE_ANGLES;




    //===========================================================================
    // Definitions intended for hardware acceleration of the HRTF 3D algorithm
    //===========================================================================



    TKSDS3D_HRTF_PARAMS_MSG = record
        Size: ULONG;           // This is the size of the struct in bytes
        Enabled: ULONG;
        SwapChannels: longbool;
        ZeroAzimuth: longbool;
        CrossFadeOutput: longbool;
        FilterSize: ULONG;     // This is the additional size of the filter coeff in bytes
    end;
    PKSDS3D_HRTF_PARAMS_MSG = ^TKSDS3D_HRTF_PARAMS_MSG;

    // HRTF filter quality levels
    TKSDS3D_HRTF_FILTER_QUALITY = (
        FULL_FILTER,
        LIGHT_FILTER,
        KSDS3D_FILTER_QUALITY_COUNT);

    TKSDS3D_HRTF_INIT_MSG = record
        Size: ULONG;       // This is the size of the struct in bytes
        Quality: TKSDS3D_HRTF_FILTER_QUALITY;
        SampleRate: single;
        MaxFilterSize: ULONG;
        FilterTransientMuteLength: ULONG;
        FilterOverlapBufferLength: ULONG;
        OutputOverlapBufferLength: ULONG;
        Reserved: ULONG;
    end;
    PKSDS3D_HRTF_INIT_MSG = ^TKSDS3D_HRTF_INIT_MSG;

    // Coefficient formats
    TKSDS3D_HRTF_COEFF_FORMAT = (
        FLOAT_COEFF,
        SHORT_COEFF,
        KSDS3D_COEFF_COUNT);

    // Filter methods
    TKSDS3D_HRTF_FILTER_METHOD = (
        DIRECT_FORM,
        CASCADE_FORM,
        KSDS3D_FILTER_METHOD_COUNT);

    // Filter methods
    TKSDS3D_HRTF_FILTER_VERSION = (
        DS3D_HRTF_VERSION_1);

    TKSDS3D_HRTF_FILTER_FORMAT_MSG = record
        FilterMethod: TKSDS3D_HRTF_FILTER_METHOD;
        CoeffFormat: TKSDS3D_HRTF_COEFF_FORMAT;
        Version: TKSDS3D_HRTF_FILTER_VERSION;
        Reserved: ULONG;
    end;
    PKSDS3D_HRTF_FILTER_FORMAT_MSG = ^TKSDS3D_HRTF_FILTER_FORMAT_MSG;

    TKSPROPERTY_HRTF3D = (
        KSPROPERTY_HRTF3D_PARAMS = 0,
        KSPROPERTY_HRTF3D_INITIALIZE,
        KSPROPERTY_HRTF3D_FILTER_FORMAT);


    //===========================================================================
    // Definitions related to the obsolete Interaural Time Delay 3D algorithm
    //===========================================================================

    // DirectSound3D FIR context
    TKSDS3D_ITD_PARAMS = record
        Channel: LONG;
        VolSmoothScale: single;
        TotalDryAttenuation: single;
        TotalWetAttenuation: single;
        SmoothFrequency: LONG;
        Delay: LONG;
    end;
    PKSDS3D_ITD_PARAMS = ^TKSDS3D_ITD_PARAMS;

    TKSDS3D_ITD_PARAMS_MSG = record
        Enabled: ULONG;
        LeftParams: TKSDS3D_ITD_PARAMS;
        RightParams: TKSDS3D_ITD_PARAMS;
        Reserved: ULONG;
    end;
    PKSDS3D_ITD_PARAMS_MSG = ^TKSDS3D_ITD_PARAMS_MSG;




    TKSPROPERTY_ITD3D = (
        KSPROPERTY_ITD3D_PARAMS = 0);


    TKSDATARANGE_AUDIO = record
        DataRange: TKSDATARANGE;
        MaximumChannels: ULONG;
        MinimumBitsPerSample: ULONG;
        MaximumBitsPerSample: ULONG;
        MinimumSampleFrequency: ULONG;
        MaximumSampleFrequency: ULONG;
    end;
    PKSDATARANGE_AUDIO = ^TKSDATARANGE_AUDIO;

    //---------------------------------------------------------------------------

 (* ToDO
//Repeatable tags contain all entries within the property, each preceeded by length
TKSPROPERTY_BIBLIOGRAPHIC             = (
    KSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
    KSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
    KSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
    KSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
    KSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
    KSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
    KSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
    KSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
    KSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
    KSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
    KSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
    KSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
    KSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
    KSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
    KSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
    KSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
    KSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
    KSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
);
*)

    TKSPROPERTY_TOPOLOGYNODE = (
        KSPROPERTY_TOPOLOGYNODE_ENABLE = 1
        //{$if (NTDDI_VERSION >= NTDDI_WINXP)
        , KSPROPERTY_TOPOLOGYNODE_RESET
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)
        );

    //===========================================================================

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)

    //#if defined(_NTDDK_)
    PRTAUDIOGETPOSITION = function(PinFileObject: PFILE_OBJECT; out ppPlayPosition: PUCHAR;
        out plOffset: LONG): NTSTATUS; stdcall;
    // {$ENDIF} // defined(_NTDDK_)

    TKSPROPERTY_RTAUDIO = (
        KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,
        //{$if (NTDDI_VERSION >= NTDDI_VISTA)}
        KSPROPERTY_RTAUDIO_BUFFER,
        KSPROPERTY_RTAUDIO_HWLATENCY,
        KSPROPERTY_RTAUDIO_POSITIONREGISTER,
        KSPROPERTY_RTAUDIO_CLOCKREGISTER,
        KSPROPERTY_RTAUDIO_BUFFER_WITH_NOTIFICATION,
        KSPROPERTY_RTAUDIO_REGISTER_NOTIFICATION_EVENT,
        KSPROPERTY_RTAUDIO_UNREGISTER_NOTIFICATION_EVENT,
        //{$ENDIF}
        //{$if (NTDDI_VERSION >= NTDDI_WIN7)}
        KSPROPERTY_RTAUDIO_QUERY_NOTIFICATION_SUPPORT,
        //{$ENDIF}
        //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}
        KSPROPERTY_RTAUDIO_PACKETCOUNT,
        KSPROPERTY_RTAUDIO_PRESENTATION_POSITION,
        KSPROPERTY_RTAUDIO_GETREADPACKET,
        KSPROPERTY_RTAUDIO_SETWRITEPACKET,
        //{$ENDIF}
        //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS5)}
        KSPROPERTY_RTAUDIO_PACKETVREGISTER
        //{$ENDIF}
        );

    //{$if (NTDDI_VERSION >= NTDDI_VISTA)}
    TKSRTAUDIO_BUFFER_PROPERTY = record
        _Property: TKSPROPERTY;
        BaseAddress: pointer;
        RequestedBufferSize: ULONG;
    end;
    PKSRTAUDIO_BUFFER_PROPERTY = ^TKSRTAUDIO_BUFFER_PROPERTY;

    TKSRTAUDIO_BUFFER_PROPERTY32 = record
        _Property: TKSPROPERTY;
        BaseAddress: ULONG;
        RequestedBufferSize: ULONG;
    end;
    PKSRTAUDIO_BUFFER_PROPERTY32 = ^TKSRTAUDIO_BUFFER_PROPERTY32;

    TKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION = record
        _Property: TKSPROPERTY;
        BaseAddress: pointer;
        RequestedBufferSize: ULONG;
        NotificationCount: ULONG;
    end;
    PKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION = ^TKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION;

    TKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION32 = record
        _Property: TKSPROPERTY;
        BaseAddress: ULONG;
        RequestedBufferSize: ULONG;
        NotificationCount: ULONG;
    end;
    PKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION32 = ^TKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION32;

    TKSRTAUDIO_BUFFER = record
        BufferAddress: pointer;
        ActualBufferSize: ULONG;
        CallMemoryBarrier: longbool;
    end;
    PKSRTAUDIO_BUFFER = ^TKSRTAUDIO_BUFFER;

    TKSRTAUDIO_BUFFER32 = record
        BufferAddress: ULONG;
        ActualBufferSize: ULONG;
        CallMemoryBarrier: longbool;
    end;
    PKSRTAUDIO_BUFFER32 = ^TKSRTAUDIO_BUFFER32;

    TKSRTAUDIO_HWLATENCY = record
        FifoSize: ULONG;
        ChipsetDelay: ULONG;
        CodecDelay: ULONG;
    end;
    PKSRTAUDIO_HWLATENCY = ^TKSRTAUDIO_HWLATENCY;

    TKSRTAUDIO_HWREGISTER_PROPERTY = record
        _Property: TKSPROPERTY;
        BaseAddress: pointer;
    end;
    PKSRTAUDIO_HWREGISTER_PROPERTY = ^TKSRTAUDIO_HWREGISTER_PROPERTY;

    TKSRTAUDIO_HWREGISTER_PROPERTY32 = record
        _Property: TKSPROPERTY;
        BaseAddress: ULONG;
    end;
    PKSRTAUDIO_HWREGISTER_PROPERTY32 = ^TKSRTAUDIO_HWREGISTER_PROPERTY32;

    TKSRTAUDIO_HWREGISTER = record
        _Register: pointer;
        Width: ULONG;
        Numerator: ULONGLONG;
        Denominator: ULONGLONG;
        Accuracy: ULONG;
    end;
    PKSRTAUDIO_HWREGISTER = ^TKSRTAUDIO_HWREGISTER;

    TKSRTAUDIO_HWREGISTER32 = record
        _Register: ULONG;
        Width: ULONG;
        Numerator: ULONGLONG;
        Denominator: ULONGLONG;
        Accuracy: ULONG;
    end;
    PKSRTAUDIO_HWREGISTER32 = ^TKSRTAUDIO_HWREGISTER32;

    TKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY = record
        _Property: TKSPROPERTY;
        NotificationEvent: THANDLE;
    end;
    PKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY = ^TKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY;

    TKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY32 = record
        _Property: TKSPROPERTY;
        NotificationEvent: ULONG;
    end;
    PKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY32 = ^TKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY32;
    //{$ENDIF}

    //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}
    TKSRTAUDIO_GETREADPACKET_INFO = record
        PacketNumber: ULONG;
        Flags: DWORD;
        PerformanceCounterValue: ULONG64;
        MoreData: longbool;
    end;
    PKSRTAUDIO_GETREADPACKET_INFO = ^TKSRTAUDIO_GETREADPACKET_INFO;

    TKSRTAUDIO_SETWRITEPACKET_INFO = record
        PacketNumber: ULONG;
        Flags: DWORD;
        EosPacketLength: ULONG;
    end;
    PKSRTAUDIO_SETWRITEPACKET_INFO = ^TKSRTAUDIO_SETWRITEPACKET_INFO;
    //{$ENDIF}

    //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS5)}
    TKSRTAUDIO_PACKETVREGISTER_PROPERTY = record
        _Property: TKSPROPERTY;
        BaseAddress: pointer;
    end;
    PKSRTAUDIO_PACKETVREGISTER_PROPERTY = ^TKSRTAUDIO_PACKETVREGISTER_PROPERTY;

    TKSRTAUDIO_PACKETVREGISTER = record
        CompletedPacketCount: PULONG64;
        CompletedPacketQPC: PULONG64;
        CompletedPacketHash: PULONG64;
    end;
    PKSRTAUDIO_PACKETVREGISTER = ^TKSRTAUDIO_PACKETVREGISTER;
    //{$ENDIF}

    //{$if (NTDDI_VERSION >= NTDDI_WIN7)}
    TKSPROPERTY_BTAUDIO = (
        KSPROPERTY_ONESHOT_RECONNECT,
        KSPROPERTY_ONESHOT_DISCONNECT);
    //{$ENDIF}

    TKSPROPERTY_DRMAUDIOSTREAM = (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID);


    //#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
    //===========================================================================

    TKSPROPERTY_SOUNDDETECTOR = (
        KSPROPERTY_SOUNDDETECTOR_SUPPORTEDPATTERNS = 1,
        KSPROPERTY_SOUNDDETECTOR_PATTERNS,
        KSPROPERTY_SOUNDDETECTOR_ARMED,
        KSPROPERTY_SOUNDDETECTOR_MATCHRESULT);

    TSOUNDDETECTOR_PATTERNHEADER = record
        Size: ULONG;
        PatternType: TGUID;
    end;
    PSOUNDDETECTOR_PATTERNHEADER = ^TSOUNDDETECTOR_PATTERNHEADER;

    TKSEVENT_SOUNDDETECTOR = (
        KSEVENT_SOUNDDETECTOR_MATCHDETECTED = 1);
    //#endif // (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

    //===========================================================================

    TKSPROPERTY_AUDIO = (
        KSPROPERTY_AUDIO_LATENCY = 1,
        KSPROPERTY_AUDIO_COPY_PROTECTION,
        KSPROPERTY_AUDIO_CHANNEL_CONFIG,
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_AUDIO_POSITION,
        KSPROPERTY_AUDIO_DYNAMIC_RANGE,
        KSPROPERTY_AUDIO_QUALITY,
        KSPROPERTY_AUDIO_SAMPLING_RATE,
        KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
        KSPROPERTY_AUDIO_MUX_SOURCE,
        KSPROPERTY_AUDIO_MUTE,
        KSPROPERTY_AUDIO_BASS,
        KSPROPERTY_AUDIO_MID,
        KSPROPERTY_AUDIO_TREBLE,
        KSPROPERTY_AUDIO_BASS_BOOST,
        KSPROPERTY_AUDIO_EQ_LEVEL,
        KSPROPERTY_AUDIO_NUM_EQ_BANDS,
        KSPROPERTY_AUDIO_EQ_BANDS,
        KSPROPERTY_AUDIO_AGC,
        KSPROPERTY_AUDIO_DELAY,
        KSPROPERTY_AUDIO_LOUDNESS,
        KSPROPERTY_AUDIO_WIDE_MODE,                 //Reserved for system use
        KSPROPERTY_AUDIO_WIDENESS,
        KSPROPERTY_AUDIO_REVERB_LEVEL,
        KSPROPERTY_AUDIO_CHORUS_LEVEL,
        KSPROPERTY_AUDIO_DEV_SPECIFIC,
        KSPROPERTY_AUDIO_DEMUX_DEST,
        KSPROPERTY_AUDIO_STEREO_ENHANCE,            //Reserved for system use
        KSPROPERTY_AUDIO_MANUFACTURE_GUID,          //Reserved for system use
        KSPROPERTY_AUDIO_PRODUCT_GUID,              //Reserved for system use
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
        KSPROPERTY_AUDIO_SURROUND_ENCODE,
        KSPROPERTY_AUDIO_3D_INTERFACE



        //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
        , KSPROPERTY_AUDIO_PEAKMETER
        , KSPROPERTY_AUDIO_ALGORITHM_INSTANCE
        , KSPROPERTY_AUDIO_FILTER_STATE
        , KSPROPERTY_AUDIO_PREFERRED_STATUS

        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

        //{$if (NTDDI_VERSION >= NTDDI_VISTA)}
        , KSPROPERTY_AUDIO_PEQ_MAX_BANDS
        , KSPROPERTY_AUDIO_PEQ_NUM_BANDS
        , KSPROPERTY_AUDIO_PEQ_BAND_CENTER_FREQ
        , KSPROPERTY_AUDIO_PEQ_BAND_Q_FACTOR
        , KSPROPERTY_AUDIO_PEQ_BAND_LEVEL
        , KSPROPERTY_AUDIO_CHORUS_MODULATION_RATE
        , KSPROPERTY_AUDIO_CHORUS_MODULATION_DEPTH
        , KSPROPERTY_AUDIO_REVERB_TIME
        , KSPROPERTY_AUDIO_REVERB_DELAY_FEEDBACK
        , KSPROPERTY_AUDIO_POSITIONEX
        , KSPROPERTY_AUDIO_MIC_ARRAY_GEOMETRY
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_VISTA)

        //{$if (NTDDI_VERSION >= NTDDI_WIN8)}
        , KSPROPERTY_AUDIO_PRESENTATION_POSITION
        , KSPROPERTY_AUDIO_WAVERT_CURRENT_WRITE_POSITION
        , KSPROPERTY_AUDIO_LINEAR_BUFFER_POSITION
        , KSPROPERTY_AUDIO_PEAKMETER2
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN8)

        //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)}
        , KSPROPERTY_AUDIO_WAVERT_CURRENT_WRITE_LASTBUFFER_POSITION
        , KSPROPERTY_AUDIO_VOLUMELIMIT_ENGAGED
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)

        //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS1)}
        , KSPROPERTY_AUDIO_MIC_SENSITIVITY // deprecated in favor of KSPROPERTY_AUDIO_MIC_SENSITIVITY2
        , KSPROPERTY_AUDIO_MIC_SNR
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS1)

        //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS4)}
        , KSPROPERTY_AUDIO_MIC_SENSITIVITY2
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS4)

        );



    TKSAUDIO_COPY_PROTECTION = record
        fCopyrighted: longbool;
        fOriginal: longbool;
    end;
    PKSAUDIO_COPY_PROTECTION = ^TKSAUDIO_COPY_PROTECTION;

    TKSAUDIO_CHANNEL_CONFIG = record
        ActiveSpeakerPositions: LONG;
    end;
    PKSAUDIO_CHANNEL_CONFIG = ^TKSAUDIO_CHANNEL_CONFIG;



    TKSAUDIO_DYNAMIC_RANGE = record
        QuietCompression: ULONG;
        LoudCompression: ULONG;
    end;
    PKSAUDIO_DYNAMIC_RANGE = ^TKSAUDIO_DYNAMIC_RANGE;

    TKSAUDIO_MIXLEVEL = record
        Mute: longbool;
        Level: LONG;
    end;
    PKSAUDIO_MIXLEVEL = ^TKSAUDIO_MIXLEVEL;

    TKSAUDIO_MIX_CAPS = record
        Mute: longbool;
        Minimum: LONG;
        Maximum: LONG;
        case integer of
            0: (Reset: LONG);
            1: (Resolution: LONG);
    end;
    PKSAUDIO_MIX_CAPS = ^TKSAUDIO_MIX_CAPS;

    TKSAUDIO_MIXCAP_TABLE = record
        InputChannels: ULONG;
        OutputChannels: ULONG;
        Capabilities: PKSAUDIO_MIX_CAPS;
    end;
    PKSAUDIO_MIXCAP_TABLE = ^TKSAUDIO_MIXCAP_TABLE;

    //{$if (NTDDI_VERSION < NTDDI_VISTA)}

    TKSPROPERTY_SYSAUDIO_DEFAULT_TYPE = (              // preferred device index
        KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
        KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
        KSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
        KSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
        KSPROPERTY_SYSAUDIO_MIXER_DEFAULT);

    //{$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)}

    TKSAUDIO_PREFERRED_STATUS = record
        Enable: longbool;
        DeviceType: TKSPROPERTY_SYSAUDIO_DEFAULT_TYPE;
        Flags: ULONG;
        Reserved: ULONG;
    end;
    PKSAUDIO_PREFERRED_STATUS = ^TKSAUDIO_PREFERRED_STATUS;

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION >= NTDDI_VISTA)}
    TKSAUDIO_POSITIONEX = record
        TimerFrequency: LARGE_INTEGER;
        TimeStamp1: LARGE_INTEGER;
        Position: TKSAUDIO_POSITION;
        TimeStamp2: LARGE_INTEGER;
    end;
    PKSAUDIO_POSITIONEX = ^TKSAUDIO_POSITIONEX;
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_VISTA)

    //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}

    TKSPROPERTY_TELEPHONY_CONTROL = (
        KSPROPERTY_TELEPHONY_PROVIDERID = 0,
        KSPROPERTY_TELEPHONY_CALLINFO,
        KSPROPERTY_TELEPHONY_CALLCONTROL,
        KSPROPERTY_TELEPHONY_PROVIDERCHANGE,
        KSPROPERTY_TELEPHONY_CALLHOLD,
        KSPROPERTY_TELEPHONY_MUTE_TX);

    TTELEPHONY_CALLTYPE = (
        TELEPHONY_CALLTYPE_CIRCUITSWITCHED = 0,
        TELEPHONY_CALLTYPE_PACKETSWITCHED_LTE,
        TELEPHONY_CALLTYPE_PACKETSWITCHED_WLAN);

    TTELEPHONY_CALLCONTROLOP = (
        TELEPHONY_CALLCONTROLOP_DISABLE = 0,
        TELEPHONY_CALLCONTROLOP_ENABLE);

    TKSTELEPHONY_CALLCONTROL = record
        CallType: TTELEPHONY_CALLTYPE;
        CallControlOp: TTELEPHONY_CALLCONTROLOP;
    end;
    PKSTELEPHONY_CALLCONTROL = ^TKSTELEPHONY_CALLCONTROL;

    TTELEPHONY_PROVIDERCHANGEOP = (
        TELEPHONY_PROVIDERCHANGEOP_END = 0,
        TELEPHONY_PROVIDERCHANGEOP_BEGIN,
        TELEPHONY_PROVIDERCHANGEOP_CANCEL);

    TKSTELEPHONY_PROVIDERCHANGE = record
        CallType: TTELEPHONY_CALLTYPE;
        ProviderChangeOp: TTELEPHONY_PROVIDERCHANGEOP;
    end;
    PKSTELEPHONY_PROVIDERCHANGE = ^TKSTELEPHONY_PROVIDERCHANGE;

    TTELEPHONY_CALLSTATE = (
        TELEPHONY_CALLSTATE_DISABLED = 0,
        TELEPHONY_CALLSTATE_ENABLED,
        TELEPHONY_CALLSTATE_HOLD,
        TELEPHONY_CALLSTATE_PROVIDERTRANSITION);

    TKSTELEPHONY_CALLINFO = record
        CallType: TTELEPHONY_CALLTYPE;
        CallState: TTELEPHONY_CALLSTATE;
    end;
    PKSTELEPHONY_CALLINFO = ^TKSTELEPHONY_CALLINFO;

    TKSPROPERTY_TELEPHONY_TOPOLOGY = (
        KSPROPERTY_TELEPHONY_ENDPOINTIDPAIR = 0,
        KSPROPERTY_TELEPHONY_VOLUME);

    TKSTOPOLOGY_ENDPOINTID = record
        TopologyName: array [0..MAX_PATH - 1] of WCHAR;  // Reference string for topology filter of an endpoint
        PinId: ULONG;                  // Topology filter pin id to which endpoint is connected
    end;
    PKSTOPOLOGY_ENDPOINTID = ^TKSTOPOLOGY_ENDPOINTID;

    TKSTOPOLOGY_ENDPOINTIDPAIR = record
        RenderEndpoint: TKSTOPOLOGY_ENDPOINTID;
        CaptureEndpoint: TKSTOPOLOGY_ENDPOINTID;
    end;
    PKSTOPOLOGY_ENDPOINTIDPAIR = ^TKSTOPOLOGY_ENDPOINTIDPAIR;


    KSPROPERTY_FMRX_TOPOLOGY = (
        KSPROPERTY_FMRX_ENDPOINTID = 0,
        KSPROPERTY_FMRX_VOLUME,
        KSPROPERTY_FMRX_ANTENNAENDPOINTID);

    KSPROPERTY_FMRX_CONTROL = (
        KSPROPERTY_FMRX_STATE = 0);


    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

    //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS4)}

    TKSEVENT_TELEPHONY = (
        KSEVENT_TELEPHONY_ENDPOINTPAIRS_CHANGED);

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS4)


    TKSMETHOD_WAVETABLE = (
        KSMETHOD_WAVETABLE_WAVE_ALLOC,
        KSMETHOD_WAVETABLE_WAVE_FREE,
        KSMETHOD_WAVETABLE_WAVE_FIND,
        KSMETHOD_WAVETABLE_WAVE_WRITE);

    TKSWAVETABLE_WAVE_DESC = record
        Identifier: TKSIDENTIFIER;                     // wave identifier
        Size: ULONG;                           // wave size
        Looped: longbool;                         // wave looped flag
        LoopPoint: ULONG;                      // wave loop point
        InROM: longbool;                          // wave InROM flag
        Format: TKSDATAFORMAT;                         // wave format
    end;
    PKSWAVETABLE_WAVE_DESC = ^TKSWAVETABLE_WAVE_DESC;


    (*  Property sets and items *)

    // {$if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)}
    TKSPROPERTY_AEC = (
        KSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
        KSPROPERTY_AEC_STATUS,
        KSPROPERTY_AEC_MODE);
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)



    TKSPROPERTY_WAVE = (
        KSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
        KSPROPERTY_WAVE_INPUT_CAPABILITIES,
        KSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
        KSPROPERTY_WAVE_BUFFER,
        KSPROPERTY_WAVE_FREQUENCY,
        KSPROPERTY_WAVE_VOLUME,
        KSPROPERTY_WAVE_PAN);

    TKSWAVE_COMPATCAPS = record
        ulDeviceType: ULONG;
    end;
    PKSWAVE_COMPATCAPS = ^TKSWAVE_COMPATCAPS;



    TKSWAVE_INPUT_CAPABILITIES = record
        MaximumChannelsPerConnection: ULONG;
        MinimumBitsPerSample: ULONG;
        MaximumBitsPerSample: ULONG;
        MinimumSampleFrequency: ULONG;
        MaximumSampleFrequency: ULONG;
        TotalConnections: ULONG;
        ActiveConnections: ULONG;
    end;
    PKSWAVE_INPUT_CAPABILITIES = ^TKSWAVE_INPUT_CAPABILITIES;

    TKSWAVE_OUTPUT_CAPABILITIES = record
        MaximumChannelsPerConnection: ULONG;
        MinimumBitsPerSample: ULONG;
        MaximumBitsPerSample: ULONG;
        MinimumSampleFrequency: ULONG;
        MaximumSampleFrequency: ULONG;
        TotalConnections: ULONG;
        StaticConnections: ULONG;
        StreamingConnections: ULONG;
        ActiveConnections: ULONG;
        ActiveStaticConnections: ULONG;
        ActiveStreamingConnections: ULONG;
        Total3DConnections: ULONG;
        Static3DConnections: ULONG;
        Streaming3DConnections: ULONG;
        Active3DConnections: ULONG;
        ActiveStatic3DConnections: ULONG;
        ActiveStreaming3DConnections: ULONG;
        TotalSampleMemory: ULONG;
        FreeSampleMemory: ULONG;
        LargestFreeContiguousSampleMemory: ULONG;
    end;
    PKSWAVE_OUTPUT_CAPABILITIES = ^TKSWAVE_OUTPUT_CAPABILITIES;

    TKSWAVE_VOLUME = record
        LeftAttenuation: LONG;
        RightAttenuation: LONG;
    end;
    PKSWAVE_VOLUME = ^TKSWAVE_VOLUME;



    TKSWAVE_BUFFER = record
        Attributes: ULONG;
        BufferSize: ULONG;
        BufferAddress: Pointer;
    end;
    PKSWAVE_BUFFER = ^TKSWAVE_BUFFER;

    TKSPROPERTY_WAVETABLE = (
        KSPROPERTY_WAVETABLE_LOAD_SAMPLE,
        KSPROPERTY_WAVETABLE_UNLOAD_SAMPLE,
        KSPROPERTY_WAVETABLE_MEMORY,
        KSPROPERTY_WAVETABLE_VERSION);



    TKSDATARANGE_MUSIC = record
        DataRange: TKSDATARANGE;
        Technology: TGUID;
        Channels: ULONG;
        Notes: ULONG;
        ChannelMask: ULONG;
    end;
    PKSDATARANGE_MUSIC = ^TKSDATARANGE_MUSIC;

    //===========================================================================

    //{$if (NTDDI_VERSION < NTDDI_WS03)

    TKSEVENT_CYCLIC_TIME = (
        KSEVENT_CYCLIC_TIME_INTERVAL);

    //{$ENDIF} // (NTDDI_VERSION < NTDDI_WS03)




    TKSPROPERTY_CYCLIC = (
        KSPROPERTY_CYCLIC_POSITION);


    TKSEVENT_AUDIO_CONTROL_CHANGE = (
        KSEVENT_CONTROL_CHANGE);

    TKSEVENT_LOOPEDSTREAMING = (
        KSEVENT_LOOPEDSTREAMING_POSITION);

    TLOOPEDSTREAMING_POSITION_EVENT_DATA = record
        KsEventData: TKSEVENTDATA;
    {$if defined(_NTDDK_)}
        Position: ULONGLONG;
{$ELSE} // !_NTDDK_
        Position: DWORDLONG;
{$ENDIF}// !_NTDDK_
    end;
    PLOOPEDSTREAMING_POSITION_EVENT_DATA = ^TLOOPEDSTREAMING_POSITION_EVENT_DATA;


    //{$if (NTDDI_VERSION <= NTDDI_WINXP)}
    TKSEVENT_SYSAUDIO = (
        KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE
        //{$if (NTDDI_VERSION == NTDDI_WINXP)
        , KSEVENT_SYSAUDIO_CHANGE_DEVICE
        //{$ENDIF}
        );

    //{$ENDIF} // (NTDDI_VERSION <= NTDDI_WINXP)


{$if (NTDDI_VERSION >= NTDDI_WINXP) AND (NTDDI_VERSION < NTDDI_VISTA)}
    TKSPROPERTY_SYSAUDIO = (
        KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
        KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
        KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
        KSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
        KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
        KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
        KSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
        KSPROPERTY_SYSAUDIO_COMPONENT_ID = 16);

{$ENDIF}// (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

{$if (NTDDI_VERSION < NTDDI_WINXP)}
    TKSPROPERTY_SYSAUDIO = (
        KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
        KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
        KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
        KSPROPERTY_SYSAUDIO_SELECT_GRAPH,
        KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE,
        KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
        KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE,
        KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK,
        KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK,
        KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES,
        KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX,
        KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY,
        KSPROPERTY_SYSAUDIO_INSTANCE_INFO,
        KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE);
{$ENDIF}// (NTDDI_VERSION < NTDDI_WINXP)

    //{$if (NTDDI_VERSION < NTDDI_VISTA)
    TSYSAUDIO_CREATE_VIRTUAL_SOURCE = record
        _Property: TKSPROPERTY;
        PinCategory: TGUID;
        PinName: TGUID;
    end;
    PSYSAUDIO_CREATE_VIRTUAL_SOURCE = ^TSYSAUDIO_CREATE_VIRTUAL_SOURCE;

    //{$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)


    //{$if (NTDDI_VERSION < NTDDI_VISTA)

    TSYSAUDIO_SELECT_GRAPH = record
        _Property: TKSPROPERTY;
        PinId: ULONG;
        NodeId: ULONG;
        Flags: ULONG;
        Reserved: ULONG;
    end;
    PSYSAUDIO_SELECT_GRAPH = ^TSYSAUDIO_SELECT_GRAPH;

    TSYSAUDIO_INSTANCE_INFO = record
        _Property: TKSPROPERTY;
        Flags: ULONG;
        DeviceNumber: ULONG;
    end;
    PSYSAUDIO_INSTANCE_INFO = ^TSYSAUDIO_INSTANCE_INFO;



    //{$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)

    //{$if (NTDDI_VERSION < NTDDI_WINXP)
    TSYSAUDIO_PREFERRED_DEVICE = record
        _Property: TKSPROPERTY;
        Flags: ULONG;
        Index: ULONG;            // KSPROPERTY_SYSAUDIO_DEFAULT_TYPE
    end;
    PSYSAUDIO_PREFERRED_DEVICE = ^TSYSAUDIO_PREFERRED_DEVICE;


    //{$ENDIF} // (NTDDI_VERSION < NTDDI_WINXP)


{$if (NTDDI_VERSION >= NTDDI_WINXP) AND (NTDDI_VERSION < NTDDI_VISTA)}
    TKSPROPERTY_SYSAUDIO_PIN = (
        KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1);

{$ENDIF}// (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

{$if (NTDDI_VERSION < NTDDI_WINXP)}
    TKSPROPERTY_SYSAUDIO_PIN = (
        KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX,
        KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE,
        KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE);
{$ENDIF}// (NTDDI_VERSION < NTDDI_WINXP)

    //{$if (NTDDI_VERSION < NTDDI_VISTA)

    TSYSAUDIO_ATTACH_VIRTUAL_SOURCE = record
        _Property: TKSPROPERTY;
        MixerPinId: ULONG;
        Reserved: ULONG;
    end;
    PSYSAUDIO_ATTACH_VIRTUAL_SOURCE = ^TSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

    //{$ENDIF} // (NTDDI_VERSION < NTDDI_VISTA)

    //===========================================================================
    TKSNODEPROPERTY = record
        _Property: TKSPROPERTY;
        NodeId: ULONG;
        Reserved: ULONG;
    end;
    PKSNODEPROPERTY = ^TKSNODEPROPERTY;

    TKSNODEPROPERTY_AUDIO_CHANNEL = record
        NodeProperty: TKSNODEPROPERTY;
        Channel: LONG;                   // value to get or set
        Reserved: ULONG;
    end;
    PKSNODEPROPERTY_AUDIO_CHANNEL = ^TKSNODEPROPERTY_AUDIO_CHANNEL;

    TKSNODEPROPERTY_AUDIO_DEV_SPECIFIC = record
        NodeProperty: TKSNODEPROPERTY;
        DevSpecificId: ULONG;
        DeviceInfo: ULONG;
        Length: ULONG;
    end;
    PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC = ^TKSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

    TKSNODEPROPERTY_AUDIO_3D_LISTENER = record
        NodeProperty: TKSNODEPROPERTY;
        ListenerId: pointer;
                 {$ifndef WIN64}
        Reserved: ULONG;
{$ENDIF}// _WIN64
    end;
    PKSNODEPROPERTY_AUDIO_3D_LISTENER = ^TKSNODEPROPERTY_AUDIO_3D_LISTENER;

    TKSNODEPROPERTY_AUDIO_PROPERTY = record
        NodeProperty: TKSNODEPROPERTY;
        AppContext: pointer;
        Length: ULONG;
                {$ifndef WIN64}
        Reserved: ULONG;
{$ENDIF}// _WIN64
    end;
    PKSNODEPROPERTY_AUDIO_PROPERTY = ^TKSNODEPROPERTY_AUDIO_PROPERTY;

    //{$if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)
    TKSPROPERTY_AUDIOGFX = (
        KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
        KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID);
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

    //===========================================================================

    //{$if (NTDDI_VERSION < NTDDI_WS03)
    TKSPROPERTY_LINEAR = (
        KSPROPERTY_LINEAR_POSITION);
    //{$ENDIF} // (NTDDI_VERSION < NTDDI_WS03)

    //===========================================================================



    // WARNING! This structure MUST be dword aligned
    // regardless of the number of data bytes.

    TKSMUSICFORMAT = record
        TimeDeltaMs: ULONG;        // Delta Milliseconds from the previous midiformat
        // in the packet. The first midiformat in the packet
        // is a delta from the PTS in the KSSTREAM_HEADER.
        ByteCount: ULONG;          // Number of bytes of data that follow this struct.
    end;
    PKSMUSICFORMAT = ^TKSMUSICFORMAT;


    // This entire set of MPEG Standard/Dialect Guids are obsolete. Do not use them.

    //====================================================================================================
    //====================================================================================================
    // The following official MPEG Formats, Subtypes and Specifiers are listed as required or optional
    // These official MPEG GUIDs are the preferred method of supporting MPEG/AC-3 media types in new code.
    // Older MPEG GUIDs should also be supported for compatibilty, but these new modes are still required.
    //====================================================================================================
    //====================================================================================================

(*
This is a summary of what media types/specifiers will be required for all DVD+DSS+DVB+DTV MPEG decoders.
These media types are what the decoder driver must accept, hardware support for all of these media types
may or may not actually be provided by the decoder natively.  These media types are intended to define
the "officially" supported MPEG/AC-3 media types that all WHQL certified decoders must implement.  This
specifically includes driver and/or hardware support for all the required standards and dialects.

All MPEG video decoders must support all of the MPEG video modes shown as [required] below.
All MPEG audio decoders must support all of the MPEG audio modes shown as [required] below.
All AC-3 audio decoders must support all of the AC-3 audio modes shown as [required] below.
The line items shown as [optional] need not be implemented, but are possible formats that might be implemented.

Note that the input/output pin formats are defined by 2 or 3 GUIDs: TYPE, SUBTYPE, and maybe SPECIFIER.
The specifiers are included if the data format is a "dialect" that needs to be differentiated during decoding.
The decoder MUST be prepared to deal with ALL requests for _required_ "Standard" formats OR _required_ "Dialects".

STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM         [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET                [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER               [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]

Note that the SPECIFIER GUIDs normally identify particular versions of MPEG such as DSS and DVD.
This approach was taken to minimize the number of DSS/DVB/DVD/DTV etc. media SUBTYPES.
These specifiers are currently required to disambiguate MPEG syntax _parsing_ by the decoder
using alternate parsing routines or downloadable firmware or hardware decode settings.

In the future these specifiers will be extended to cover new KS MPEG flavors such as DVB and DTV.
Thus, the optional specifiers will be subject to clarification and/or definition as they are needed.

Important note: Per the ITU MPEG specs, MPEG 2 media may contain pure MPEG 1 syntax and
any "MPEG 2" PES packets may actually contain MPEG 1 payloads and MPEG 1 syntax.  Some MPEG
broadcasts can revert from MPEG2 to MPEG1 format data at their discretion, without warning.

CAUTION: Decoders MUST attempt to process MPEG data AS SOON AS POSSIBLE after reception.
In particular, elementary MPEG or MPEG PES packet streams should not be aggregated into DVD
"pack headers" internally before submission to the codec hardware if AT ALL POSSIBLE.  The
reason is that mpeg data may need to be processed immediately but there may be no additional
MPEG data forthcoming to fill up the PES packet OR DVD "pack" in a timely fashion.  This is
particularly true of MPEG dialects that utilize "repeat field signally" to reuse the last
decoded MPEG video field.

*)




    TKSPROPERTY_MPEG2VID = (
        KSPROPERTY_MPEG2VID_MODES,          // available output modes of decoder
        KSPROPERTY_MPEG2VID_CUR_MODE,       // current mode of the decoder
        KSPROPERTY_MPEG2VID_4_3_RECT,       // output coordinates for 4:3 source
        KSPROPERTY_MPEG2VID_16_9_RECT,      // output coordinates for 16:9 source
        KSPROPERTY_MPEG2VID_16_9_PANSCAN   // pan and scan vectors
        );



    // rectangle definitions for the 4/3 and 16/9 cropping properties of
    // the MPEG2Video decoder


    TKSMPEGVID_RECT = record
        StartX: ULONG;
        StartY: ULONG;
        EndX: ULONG;
        EndY: ULONG;
    end;
    PKSMPEGVID_RECT = ^TKSMPEGVID_RECT;


    // Params for pan / scan




    TKSPROPERTY_AC3 = (
        KSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
        KSPROPERTY_AC3_ALTERNATE_AUDIO,
        KSPROPERTY_AC3_DOWNMIX,
        KSPROPERTY_AC3_BIT_STREAM_MODE,
        KSPROPERTY_AC3_DIALOGUE_LEVEL,
        KSPROPERTY_AC3_LANGUAGE_CODE,
        KSPROPERTY_AC3_ROOM_TYPE);

    TKSAC3_ERROR_CONCEALMENT = record
        fRepeatPreviousBlock: longbool;
        fErrorInCurrentBlock: longbool;
    end;
    PKSAC3_ERROR_CONCEALMENT = ^TKSAC3_ERROR_CONCEALMENT;

    TKSAC3_ALTERNATE_AUDIO = record
        fStereo: longbool;
        DualMode: ULONG;
    end;
    PKSAC3_ALTERNATE_AUDIO = ^TKSAC3_ALTERNATE_AUDIO;



    TKSAC3_DOWNMIX = record
        fDownMix: longbool;
        fDolbySurround: longbool;
    end;
    PKSAC3_DOWNMIX = ^TKSAC3_DOWNMIX;

    TKSAC3_BIT_STREAM_MODE = record
        BitStreamMode: LONG;
    end;
    PKSAC3_BIT_STREAM_MODE = ^TKSAC3_BIT_STREAM_MODE;



    TKSAC3_DIALOGUE_LEVEL = record
        DialogueLevel: ULONG;
    end;
    PKSAC3_DIALOGUE_LEVEL = ^TKSAC3_DIALOGUE_LEVEL;

    TKSAC3_ROOM_TYPE = record
        fLargeRoom: longbool;
    end;
    PKSAC3_ROOM_TYPE = ^TKSAC3_ROOM_TYPE;



    TKSPROPERTY_AUDDECOUT = (
        KSPROPERTY_AUDDECOUT_MODES,         // available output modes of decoder
        KSPROPERTY_AUDDECOUT_CUR_MODE      // current mode of the decoder
        );


    TKSPROPERTY_DVDSUBPIC = (
        KSPROPERTY_DVDSUBPIC_PALETTE,
        KSPROPERTY_DVDSUBPIC_HLI,
        KSPROPERTY_DVDSUBPIC_COMPOSIT_ON  // TRUE for subpicture is displayed
        );

    TKS_DVD_YCrCb = record
        Reserved: UCHAR;
        Y: UCHAR;
        Cr: UCHAR;
        Cb: UCHAR;
    end;
    PKS_DVD_YCrCb = ^TKS_DVD_YCrCb;

(* The KS_DVD_YUV structure is now superseded by KS_DVD_YCrCb above and is
   here for backward compatibility only *)

    TKS_DVD_YUV = record
        Reserved: UCHAR;
        Y: UCHAR;
        V: UCHAR;
        U: UCHAR;
    end;
    PKS_DVD_YUV = ^TKS_DVD_YUV;

    TKSPROPERTY_SPPAL = record
        sppal: array [0..15] of TKS_DVD_YUV;
    end;
    PKSPROPERTY_SPPAL = ^TKSPROPERTY_SPPAL;

    TKS_COLCON = record
        emph1col: 0..15;
        emph2col: 0..15;
        backcol: 0..15;
        patcol: 0..15;
        emph1con: 0..15;
        emph2con: 0..15;
        backcon: 0..15;
        patcon: 0..15;
    end;
    PKS_COLCON = ^TKS_COLCON;

    TKSPROPERTY_SPHLI = record
        HLISS: USHORT;
        Reserved: USHORT;
        StartPTM: ULONG;   // start presentation time in x/90000
        EndPTM: ULONG;     // end PTM in x/90000
        StartX: USHORT;
        StartY: USHORT;
        StopX: USHORT;
        StopY: USHORT;
        ColCon: TKS_COLCON;     // color contrast description (4 bytes as given in HLI)
    end;
    PKSPROPERTY_SPHLI = ^TKSPROPERTY_SPHLI;

    TKSPROPERTY_COMPOSIT_ON = longbool;
    PKSPROPERTY_COMPOSIT_ON = ^TKSPROPERTY_COMPOSIT_ON;

    TKSPROPERTY_COPYPROT = (
        KSPROPERTY_DVDCOPY_CHLG_KEY = $01,
        KSPROPERTY_DVDCOPY_DVD_KEY1,
        KSPROPERTY_DVDCOPY_DEC_KEY2,
        KSPROPERTY_DVDCOPY_TITLE_KEY,
        KSPROPERTY_COPY_MACROVISION,
        KSPROPERTY_DVDCOPY_REGION,
        KSPROPERTY_DVDCOPY_SET_COPY_STATE,
        KSPROPERTY_DVDCOPY_DISC_KEY = $80);

    TKS_DVDCOPY_CHLGKEY = record
        ChlgKey: array [0..9] of byte;
        Reserved: array[0..1] of byte;
    end;
    PKS_DVDCOPY_CHLGKEY = ^TKS_DVDCOPY_CHLGKEY;

    TKS_DVDCOPY_BUSKEY = record
        BusKey: array [0..4] of byte;
        Reserved: PBYTE;
    end;
    PKS_DVDCOPY_BUSKEY = ^TKS_DVDCOPY_BUSKEY;


    TKS_DVDCOPY_DISCKEY = record
        DiscKey: array[0..2047] of byte;
    end;
    PKS_DVDCOPY_DISCKEY = ^TKS_DVDCOPY_DISCKEY;

    TKS_DVDCOPY_REGION = record
        Reserved: UCHAR;
        RegionData: UCHAR;
        Reserved2: array [0..1] of UCHAR;
    end;
    PKS_DVDCOPY_REGION = ^TKS_DVDCOPY_REGION;

    TKS_DVDCOPY_TITLEKEY = record
        KeyFlags: ULONG;
        ReservedNT: array [0..1] of ULONG;
        TitleKey: array[0..5] of UCHAR;
        Reserved: array [0..1] of UCHAR;
    end;
    PKS_DVDCOPY_TITLEKEY = ^TKS_DVDCOPY_TITLEKEY;

    TKS_COPY_MACROVISION = record
        MACROVISIONLevel: ULONG;
    end;
    PKS_COPY_MACROVISION = ^TKS_COPY_MACROVISION;

    TKS_DVDCOPY_SET_COPY_STATE = record
        DVDCopyState: ULONG;
    end;
    PKS_DVDCOPY_SET_COPY_STATE = ^TKS_DVDCOPY_SET_COPY_STATE;

    TKS_DVDCOPYSTATE = (
        KS_DVDCOPYSTATE_INITIALIZE,         // indicates we are starting a full
        // copy protection sequence.
        KS_DVDCOPYSTATE_INITIALIZE_TITLE,   // indicates we are starting a title
        // key copy protection sequence
        KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
        KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
        KS_DVDCOPYSTATE_DONE);

    TKS_COPY_MACROVISION_LEVEL = (
        KS_MACROVISION_DISABLED,
        KS_MACROVISION_LEVEL1,
        KS_MACROVISION_LEVEL2,
        KS_MACROVISION_LEVEL3);
    PKS_COPY_MACROVISION_LEVEL = ^TKS_COPY_MACROVISION_LEVEL;


    TKS_RGBQUAD = record // rgbq
        rgbBlue: byte;
        rgbGreen: byte;
        rgbRed: byte;
        rgbReserved: byte;
    end;
    PKS_RGBQUAD = ^TKS_RGBQUAD;



    TKS_BITMAPINFOHEADER = record
        biSize: DWORD;
        biWidth: LONG;
        biHeight: LONG;
        biPlanes: word;
        biBitCount: word;
        biCompression: DWORD;
        biSizeImage: DWORD;
        biXPelsPerMeter: LONG;
        biYPelsPerMeter: LONG;
        biClrUsed: DWORD;
        biClrImportant: DWORD;
    end;
    PKS_BITMAPINFOHEADER = ^TKS_BITMAPINFOHEADER;

    // Used for true colour images that also have a palette

    TKS_TRUECOLORINFO = record
        dwBitMasks: array [0..KS_iMASK_COLORS - 1] of DWORD;
        bmiColors: array [0..KS_iPALETTE_COLORS - 1] of TKS_RGBQUAD;
    end;
    PKS_TRUECOLORINFO = ^TKS_TRUECOLORINFO;



    TREFERENCE_TIME = LONGLONG;

    // The BITMAPINFOHEADER contains all the details about the video stream such
    // as the actual image dimensions and their pixel depth. A source filter may
    // also request that the sink take only a section of the video by providing a
    // clipping rectangle in rcSource. In the worst case where the sink filter
    // forgets to check this on connection it will simply render the whole thing
    // which isn't a disaster. Ideally a sink filter will check the rcSource and
    // if it doesn't support image extraction and the rectangle is not empty then
    // it will reject the connection. A filter should use SetRectEmpty to reset a
    // rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
    // The rcTarget specifies the destination rectangle for the video, for most
    // source filters they will set this to all zeroes, a downstream filter may
    // request that the video be placed in a particular area of the buffers it
    // supplies in which case it will call QueryAccept with a non empty target

    TKS_VIDEOINFOHEADER = record
        rcSource: TRECT;          // The bit we really want to use
        rcTarget: TRECT;          // Where the video should go
        dwBitRate: DWORD;         // Approximate bit data rate
        dwBitErrorRate: DWORD;    // Bit error rate for this stream
        AvgTimePerFrame: TREFERENCE_TIME;   // Average time per frame (100ns units)
        bmiHeader: TKS_BITMAPINFOHEADER;
    end;
    PKS_VIDEOINFOHEADER = ^TKS_VIDEOINFOHEADER;


    // !!! WARNING !!!
    // DO NOT use the following structure unless you are sure that the BITMAPINFOHEADER
    // has a normal biSize == sizeof(BITMAPINFOHEADER) !
    // !!! WARNING !!!

    TKS_VIDEOINFO = record
        rcSource: TRECT;          // The bit we really want to use
        rcTarget: TRECT;          // Where the video should go
        dwBitRate: DWORD;         // Approximate bit data rate
        dwBitErrorRate: DWORD;    // Bit error rate for this stream
        AvgTimePerFrame: TREFERENCE_TIME;   // Average time per frame (100ns units)
        bmiHeader: TKS_BITMAPINFOHEADER;
        case integer of
            0: (bmiColors: array [0..KS_iPALETTE_COLORS - 1] of TKS_RGBQUAD);     // Colour palette
            1: (dwBitMasks: array [0..KS_iMASK_COLORS - 1] of DWORD);       // True colour masks
            2: (TrueColorInfo: TKS_TRUECOLORINFO);                     // Both of the above
    end;
    PKS_VIDEOINFO = ^TKS_VIDEOINFO;

    // VBI
    // Used for NABTS, CC, Intercast, WST
    TKS_VBIINFOHEADER = record
        StartLine: ULONG;              // inclusive
        EndLine: ULONG;                // inclusive
        SamplingFrequency: ULONG;      // Hz.
        MinLineStartTime: ULONG;       // microSec * 100 from HSync LE
        MaxLineStartTime: ULONG;       // microSec * 100 from HSync LE
        ActualLineStartTime: ULONG;    // microSec * 100 from HSync LE
        ActualLineEndTime: ULONG;      // microSec * 100 from HSync LE
        VideoStandard: ULONG;          // KS_AnalogVideoStandard*
        SamplesPerLine: ULONG;
        StrideInBytes: ULONG;          // May be > SamplesPerLine
        BufferSize: ULONG;             // Bytes
    end;
    PKS_VBIINFOHEADER = ^TKS_VBIINFOHEADER;

    // Analog video variant - Use this when the format is FORMAT_AnalogVideo

    // rcSource defines the portion of the active video signal to use
    // rcTarget defines the destination rectangle
    //    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
    // dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
    // dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

    TKS_ANALOGVIDEOINFO = record
        rcSource: TRECT;           // Width max is 720, height varies w/ TransmissionStd
        rcTarget: TRECT;           // Where the video should go
        dwActiveWidth: DWORD;      // Always 720 (CCIR-601 active samples per line)
        dwActiveHeight: DWORD;     // 483 for NTSC, 575 for PAL/SECAM
        AvgTimePerFrame: TREFERENCE_TIME;    // Normal ActiveMovie units (100 nS)
    end;
    PKS_ANALOGVIDEOINFO = ^TKS_ANALOGVIDEOINFO;

    //===========================================================================
    // Data packet passed on Analog video stream channel change
    //===========================================================================



    TKS_TVTUNER_CHANGE_INFO = record
        dwFlags: DWORD;                // KS_TVTUNER_CHANGE_*
        dwCountryCode: DWORD;
        dwAnalogVideoStandard: DWORD;  // KS_AnalogVideoStandard
        dwChannel: DWORD;
    end;
    PKS_TVTUNER_CHANGE_INFO = ^TKS_TVTUNER_CHANGE_INFO;

    //===========================================================================
    // Video format blocks
    //===========================================================================

    TKS_MPEG2Level = (
        KS_MPEG2Level_Low,
        KS_MPEG2Level_Main,
        KS_MPEG2Level_High1440,
        KS_MPEG2Level_High);

    TKS_MPEG2Profile = (
        KS_MPEG2Profile_Simple,
        KS_MPEG2Profile_Main,
        KS_MPEG2Profile_SNRScalable,
        KS_MPEG2Profile_SpatiallyScalable,
        KS_MPEG2Profile_High);



    TKS_VIDEOINFOHEADER2 = record
        rcSource: TRECT;
        rcTarget: TRECT;
        dwBitRate: DWORD;
        dwBitErrorRate: DWORD;
        AvgTimePerFrame: TREFERENCE_TIME;
        dwInterlaceFlags: DWORD;
        // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
        dwCopyProtectFlags: DWORD;
        // use KS_COPYPROTECT_* defines. Reject connection if undefined bits are not 0
        dwPictAspectRatioX: DWORD; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
        dwPictAspectRatioY: DWORD; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
        case integer of
            0: (dwControlFlags: DWORD;               // use KS_AMCONTROL_* defines, use this from now on
                dwReserved2: DWORD;        // must be 0; reject connection otherwise
                bmiHeader: TKS_BITMAPINFOHEADER);
            1: (dwReserved1: DWORD);
        // for backward compatiblity (was "must be 0";  connection rejected otherwise)
    end;
    PKS_VIDEOINFOHEADER2 = ^TKS_VIDEOINFOHEADER2;


    TKS_MPEG1VIDEOINFO = record
        hdr: TKS_VIDEOINFOHEADER; // Compatible with VIDEOINFO
        dwStartTimeCode: DWORD; // 25-bit Group of pictures time code at start of data
        cbSequenceHeader: DWORD; // Length in bytes of bSequenceHeader
        bSequenceHeader: PByte; // Sequence header including quantization matrices if any
    end;
    PKS_MPEG1VIDEOINFO = ^TKS_MPEG1VIDEOINFO;

    TKS_MPEGVIDEOINFO2 = record
        hdr: TKS_VIDEOINFOHEADER2;
        dwStartTimeCode: DWORD;        //  ?? not used for DVD ??
        cbSequenceHeader: DWORD;       // is 0 for DVD (no sequence header)
        dwProfile: DWORD;              // use enum MPEG2Profile
        dwLevel: DWORD;                // use enum MPEG2Level
        dwFlags: DWORD;
        // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
        bSequenceHeader: PDWORD;     // DWORD instead of Byte for alignment purposes
        //   For MPEG-2, if a sequence_header is included, the sequence_extension
        //   should also be included
    end;
    PKS_MPEGVIDEOINFO2 = ^TKS_MPEGVIDEOINFO2;


    TKS_H264VIDEOINFO = record
        // from UVC 1.5 H.264 frame descriptor
        wWidth: word;
        wHeight: word;
        wSARwidth: word;
        wSARheight: word;
        wProfile: word;
        bLevelIDC: byte;
        wConstrainedToolset: word;
        bmSupportedUsages: DWORD;
        bmCapabilities: word;
        bmSVCCapabilities: DWORD;
        bmMVCCapabilities: DWORD;
        dwFrameInterval: DWORD;

        // from UVC 1.5 H.264 format descriptor
        bMaxCodecConfigDelay: byte;
        bmSupportedSliceModes: byte;
        bmSupportedSyncFrameTypes: byte;
        bResolutionScaling: byte;
        bSimulcastSupport: byte;
        bmSupportedRateControlModes: byte;
        wMaxMBperSecOneResolutionNoScalability: word;
        wMaxMBperSecTwoResolutionsNoScalability: word;
        wMaxMBperSecThreeResolutionsNoScalability: word;
        wMaxMBperSecFourResolutionsNoScalability: word;
        wMaxMBperSecOneResolutionTemporalScalability: word;
        wMaxMBperSecTwoResolutionsTemporalScalablility: word;
        wMaxMBperSecThreeResolutionsTemporalScalability: word;
        wMaxMBperSecFourResolutionsTemporalScalability: word;
        wMaxMBperSecOneResolutionTemporalQualityScalability: word;
        wMaxMBperSecTwoResolutionsTemporalQualityScalability: word;
        wMaxMBperSecThreeResolutionsTemporalQualityScalablity: word;
        wMaxMBperSecFourResolutionsTemporalQualityScalability: word;
        wMaxMBperSecOneResolutionTemporalSpatialScalability: word;
        wMaxMBperSecTwoResolutionsTemporalSpatialScalability: word;
        wMaxMBperSecThreeResolutionsTemporalSpatialScalablity: word;
        wMaxMBperSecFourResolutionsTemporalSpatialScalability: word;
        wMaxMBperSecOneResolutionFullScalability: word;
        wMaxMBperSecTwoResolutionsFullScalability: word;
        wMaxMBperSecThreeResolutionsFullScalability: word;
        wMaxMBperSecFourResolutionsFullScalability: word;
    end;
    PKS_H264VIDEOINFO = ^TKS_H264VIDEOINFO;

    //===========================================================================
    // Audio format blocks
    //===========================================================================



    TKS_MPEGAUDIOINFO = record
        dwFlags: DWORD;
        // use KS_MPEGAUDIOINFO_* defines.  Reject connection if undefined bits are not 0
        dwReserved1: DWORD;        // must be 0; reject connection otherwise
        dwReserved2: DWORD;        // must be 0; reject connection otherwise
        dwReserved3: DWORD;        // must be 0; reject connection otherwise
    end;
    PKS_MPEGAUDIOINFO = ^TKS_MPEGAUDIOINFO;

    //===========================================================================
    // Video DATAFORMATs
    //===========================================================================

    TKS_DATAFORMAT_VIDEOINFOHEADER = record
        DataFormat: TKSDATAFORMAT;
        VideoInfoHeader: TKS_VIDEOINFOHEADER;
    end;
    PKS_DATAFORMAT_VIDEOINFOHEADER = ^TKS_DATAFORMAT_VIDEOINFOHEADER;

    TKS_DATAFORMAT_VIDEOINFOHEADER2 = record
        DataFormat: TKSDATAFORMAT;
        VideoInfoHeader2: TKS_VIDEOINFOHEADER2;
    end;
    PKS_DATAFORMAT_VIDEOINFOHEADER2 = ^TKS_DATAFORMAT_VIDEOINFOHEADER2;

    TKS_DATAFORMAT_MPEGVIDEOINFO2 = record
        DataFormat: TKSDATAFORMAT;
        MpegVideoInfoHeader2: TKS_MPEGVIDEOINFO2;
    end;
    PKS_DATAFORMAT_MPEGVIDEOINFO2 = ^TKS_DATAFORMAT_MPEGVIDEOINFO2;

    TKS_DATAFORMAT_H264VIDEOINFO = record
        DataFormat: TKSDATAFORMAT;
        H264VideoInfoHeader: TKS_H264VIDEOINFO;
    end;
    PKS_DATAFORMAT_H264VIDEOINFO = ^TKS_DATAFORMAT_H264VIDEOINFO;

    TKS_DATAFORMAT_IMAGEINFO = record
        DataFormat: TKSDATAFORMAT;
        ImageInfoHeader: TKS_BITMAPINFOHEADER;
    end;
    PKS_DATAFORMAT_IMAGEINFO = ^TKS_DATAFORMAT_IMAGEINFO;


    TKS_DATAFORMAT_VIDEOINFO_PALETTE = record
        DataFormat: TKSDATAFORMAT;
        VideoInfo: TKS_VIDEOINFO;
    end;
    PKS_DATAFORMAT_VIDEOINFO_PALETTE = ^TKS_DATAFORMAT_VIDEOINFO_PALETTE;

    TKS_DATAFORMAT_VBIINFOHEADER = record
        DataFormat: TKSDATAFORMAT;
        VBIInfoHeader: TKS_VBIINFOHEADER;
    end;
    PKS_DATAFORMAT_VBIINFOHEADER = ^TKS_DATAFORMAT_VBIINFOHEADER;

    TKS_VIDEO_STREAM_CONFIG_CAPS = record
        guid: TGUID;                  // will be MEDIATYPE_Video
        VideoStandard: ULONG;        // logical OR of all AnalogVideoStandards
        // supported
        InputSize: SIZE;             // the inherent size of the incoming signal
        // (every pixel unique)
        MinCroppingSize: SIZE;       // smallest rcSrc cropping rect allowed
        MaxCroppingSize: SIZE;       // largest rcSrc cropping rect allowed
        CropGranularityX: integer;       // granularity of cropping size
        CropGranularityY: integer;
        CropAlignX: integer;             // alignment of cropping rect
        CropAlignY: integer;
        MinOutputSize: SIZE;         // smallest bitmap stream can produce
        MaxOutputSize: SIZE;         // largest  bitmap stream can produce
        OutputGranularityX: integer;     // granularity of output bitmap size
        OutputGranularityY: integer;
        StretchTapsX: integer;           // 0, no stretch, 1 pix dup, 2 interp, ...
        StretchTapsY: integer;           //    Describes quality of hardware scaler
        ShrinkTapsX: integer;
        ShrinkTapsY: integer;
        MinFrameInterval: LONGLONG;  // 100 nS units
        MaxFrameInterval: LONGLONG;
        MinBitsPerSecond: LONG;
        MaxBitsPerSecond: LONG;
    end;
    PKS_VIDEO_STREAM_CONFIG_CAPS = ^TKS_VIDEO_STREAM_CONFIG_CAPS;




    //===========================================================================
    // Video DATARANGEs
    //===========================================================================

    TKS_DATARANGE_VIDEO = record
        DataRange: TKSDATARANGE;
        bFixedSizeSamples: longbool;      // all samples same size?
        bTemporalCompression: longbool;   // all I frames?
        StreamDescriptionFlags: DWORD; // KS_VIDEO_DESC_*
        MemoryAllocationFlags: DWORD;  // KS_VIDEO_ALLOC_*
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        VideoInfoHeader: TKS_VIDEOINFOHEADER;        // default format
    end;
    PKS_DATARANGE_VIDEO = ^TKS_DATARANGE_VIDEO;

    TKS_DATARANGE_VIDEO2 = record
        DataRange: TKSDATARANGE;
        bFixedSizeSamples: longbool;      // all samples same size?
        bTemporalCompression: longbool;   // all I frames?
        StreamDescriptionFlags: DWORD; // KS_VIDEO_DESC_*
        MemoryAllocationFlags: DWORD;  // KS_VIDEO_ALLOC_*
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        VideoInfoHeader: TKS_VIDEOINFOHEADER2;        // default format
    end;
    PKS_DATARANGE_VIDEO2 = ^TKS_DATARANGE_VIDEO2;

    TKS_DATARANGE_MPEG1_VIDEO = record
        DataRange: TKSDATARANGE;
        bFixedSizeSamples: longbool; // all samples same size?
        bTemporalCompression: longbool; // all I frames?
        StreamDescriptionFlags: DWORD; // KS_VIDEO_DESC_*
        MemoryAllocationFlags: DWORD; // KS_VIDEO_ALLOC_*
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        VideoInfoHeader: TKS_MPEG1VIDEOINFO; // default format
    end;
    PKS_DATARANGE_MPEG1_VIDEO = ^TKS_DATARANGE_MPEG1_VIDEO;

    TKS_DATARANGE_MPEG2_VIDEO = record
        DataRange: TKSDATARANGE;
        bFixedSizeSamples: longbool;      // all samples same size?
        bTemporalCompression: longbool;   // all I frames?
        StreamDescriptionFlags: DWORD; // KS_VIDEO_DESC_*
        MemoryAllocationFlags: DWORD;  // KS_VIDEO_ALLOC_*
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        VideoInfoHeader: TKS_MPEGVIDEOINFO2;        // default format
    end;
    PKS_DATARANGE_MPEG2_VIDEO = ^TKS_DATARANGE_MPEG2_VIDEO;

    TKS_DATARANGE_H264_VIDEO = record
        DataRange: TKSDATARANGE;
        bFixedSizeSamples: longbool;      // all samples same size?
        bTemporalCompression: longbool;   // all I frames?
        StreamDescriptionFlags: DWORD; // KS_VIDEO_DESC_*
        MemoryAllocationFlags: DWORD;  // KS_VIDEO_ALLOC_*
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        VideoInfoHeader: TKS_H264VIDEOINFO;        // default format
    end;
    PKS_DATARANGE_H264_VIDEO = ^TKS_DATARANGE_H264_VIDEO;

    TKS_DATARANGE_IMAGE = record
        DataRange: TKSDATARANGE;
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        ImageInfoHeader: TKS_BITMAPINFOHEADER;
    end;
    PKS_DATARANGE_IMAGE = ^TKS_DATARANGE_IMAGE;

    TKS_DATARANGE_VIDEO_PALETTE = record
        DataRange: TKSDATARANGE;
        bFixedSizeSamples: longbool;      // all samples same size?
        bTemporalCompression: longbool;   // all I frames?
        StreamDescriptionFlags: DWORD; // KS_VIDEO_DESC_*
        MemoryAllocationFlags: DWORD;  // KS_VIDEO_ALLOC_*
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        VideoInfo: TKS_VIDEOINFO;              // default format
    end;
    PKS_DATARANGE_VIDEO_PALETTE = ^TKS_DATARANGE_VIDEO_PALETTE;

    TKS_DATARANGE_VIDEO_VBI = record
        DataRange: TKSDATARANGE;
        bFixedSizeSamples: longbool;      // all samples same size?
        bTemporalCompression: longbool;   // all I frames?
        StreamDescriptionFlags: DWORD; // KS_VIDEO_DESC_*
        MemoryAllocationFlags: DWORD;  // KS_VIDEO_ALLOC_*
        ConfigCaps: TKS_VIDEO_STREAM_CONFIG_CAPS;
        VBIInfoHeader: TKS_VBIINFOHEADER;          // default format
    end;
    PKS_DATARANGE_VIDEO_VBI = ^TKS_DATARANGE_VIDEO_VBI;

    TKS_DATARANGE_ANALOGVIDEO = record
        DataRange: TKSDATARANGE;
        AnalogVideoInfo: TKS_ANALOGVIDEOINFO;
    end;
    PKS_DATARANGE_ANALOGVIDEO = ^TKS_DATARANGE_ANALOGVIDEO;



    // {$if (NTDDI_VERSION >= NTDDI_WINXP)

    //////////////////////////////////////////////////////////////
    // Capture driver VBI property sets
    //////////////////////////////////////////////////////////////


    TKSPROPERTY_VBICAP = (
        KSPROPERTY_VBICAP_PROPERTIES_PROTECTION = $01);

    TVBICAP_PROPERTIES_PROTECTION_S = record
        _Property: TKSPROPERTY;
        StreamIndex: ULONG;                     // Index of stream
        Status: ULONG;
    end;
    PVBICAP_PROPERTIES_PROTECTION_S = ^TVBICAP_PROPERTIES_PROTECTION_S;


    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    (***************************************************************************)
    (* VBI Related GUIDs, structs and properties for codecs(generic, cc, nabts)*)
    (***************************************************************************)



    //////////////////////////////////////////////////////////////
    // Stream Format FEC-corrected NABTS bundles
    //////////////////////////////////////////////////////////////



    TNABTSFEC_BUFFER = record
        dataSize: ULONG;
        groupID: USHORT;
        Reserved: USHORT;
        Data: array [0..NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE - 1] of UCHAR;
    end;
    PNABTSFEC_BUFFER = ^TNABTSFEC_BUFFER;

    //////////////////////////////////////////////////////////////
    // vbi codec filtering pin properties
    //////////////////////////////////////////////////////////////


    TKSPROPERTY_VBICODECFILTERING = (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = $01,
        KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
        KSPROPERTY_VBICODECFILTERING_STATISTICS);

    TVBICODECFILTERING_SCANLINES = record
        DwordBitArray: array[0..31] of DWORD;      // An array of scanline bits 0..1024(32*32)
    end;
    PVBICODECFILTERING_SCANLINES = ^TVBICODECFILTERING_SCANLINES;

    TVBICODECFILTERING_NABTS_SUBSTREAMS = record
        SubstreamMask: array [0..127] of DWORD;   // An array of 4096 bits (one for each NABTS GroupID)
    end;
    PVBICODECFILTERING_NABTS_SUBSTREAMS = ^TVBICODECFILTERING_NABTS_SUBSTREAMS;

    TVBICODECFILTERING_CC_SUBSTREAMS = record
        SubstreamMask: DWORD;        // An array of 32 bits (see KS_CC_SUBSTREAM *)
    end;
    PVBICODECFILTERING_CC_SUBSTREAMS = ^TVBICODECFILTERING_CC_SUBSTREAMS;


    TCC_BYTE_PAIR = record
        Decoded: array [0..1] of byte;
        Reserved: USHORT;
    end;
    PCC_BYTE_PAIR = ^TCC_BYTE_PAIR;

    TCC_HW_FIELD = record
        ScanlinesRequested: TVBICODECFILTERING_SCANLINES;
        fieldFlags: ULONG;    // KS_VBI_FLAG_FIELD1,2
        PictureNumber: LONGLONG;
        Lines: array[0..CC_MAX_HW_DECODE_LINES - 1] of TCC_BYTE_PAIR;
    end;
    PCC_HW_FIELD = ^TCC_HW_FIELD;

    ///////////////////////////////////////////////////////////////////
    // Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
    ///////////////////////////////////////////////////////////////////

    // These low-level structures are byte packed( -Zp1 )
{$Z1}
    TNABTS_BUFFER_LINE = record
        Confidence: byte;
        Bytes: array [0..NABTS_BYTES_PER_LINE - 1] of byte;
    end;
    PNABTS_BUFFER_LINE = ^TNABTS_BUFFER_LINE;


    TNABTS_BUFFER = record
        ScanlinesRequested: TVBICODECFILTERING_SCANLINES;
        PictureNumber: LONGLONG;
        NabtsLines: array [0..MAX_NABTS_VBI_LINES_PER_FIELD] of TNABTS_BUFFER_LINE;
    end;
    PNABTS_BUFFER = ^TNABTS_BUFFER;
{$Z4}




    // {$if (NTDDI_VERSION >= NTDDI_WINXP)



    TWST_BUFFER_LINE = record
        Confidence: byte;
        Bytes: array[0..WST_BYTES_PER_LINE - 1] of byte;
    end;
    PWST_BUFFER_LINE = ^TWST_BUFFER_LINE;

    TWST_BUFFER = record
        ScanlinesRequested: TVBICODECFILTERING_SCANLINES;
        WstLines: array[0..MAX_WST_VBI_LINES_PER_FIELD - 1] of TWST_BUFFER_LINE;
    end;
    PWST_BUFFER = ^TWST_BUFFER;

    // {$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)


    // Common codec statistics


    TVBICODECFILTERING_STATISTICS_COMMON = record
        InputSRBsProcessed: DWORD;         // upstream SRBs received
        OutputSRBsProcessed: DWORD;        // downstream SRBs sent
        SRBsIgnored: DWORD;                // SRBs ignored due to no requests
        InputSRBsMissing: DWORD;           // SRBs dropped upstream
        OutputSRBsMissing: DWORD;          // Output dropped because no SRB pending
        OutputFailures: DWORD;             // dropped because of other failure
        InternalErrors: DWORD;             // could not process due to integer. failure
        ExternalErrors: DWORD;             // could not process due to ext. failure
        InputDiscontinuities: DWORD;       // discontinuities received
        DSPFailures: DWORD;                // DSP confidence failure
        TvTunerChanges: DWORD;
        // number of received KS_TVTUNER_CHANGE_BEGIN_TUNE and KS_TVTUNER_CHANGE_END_TUNE pairs.
        VBIHeaderChanges: DWORD;           // number of received KS_VBI_FLAG_VBIINFOHEADER_CHANGE
        LineConfidenceAvg: DWORD;          // Average of all DSP confidence results
        BytesOutput: DWORD;                // Bytes sent downstream
    end;
    PVBICODECFILTERING_STATISTICS_COMMON = ^TVBICODECFILTERING_STATISTICS_COMMON;

    TVBICODECFILTERING_STATISTICS_COMMON_PIN = record
        SRBsProcessed: DWORD;              // SRBs sent/received
        SRBsIgnored: DWORD;                // SRBs ignored due to filtering
        SRBsMissing: DWORD;                // SRBs not sent/received
        InternalErrors: DWORD;             // could not send/receive due to integer. failure
        ExternalErrors: DWORD;             // could not send/receive due to ext. failure
        Discontinuities: DWORD;            // discontinuities received/sent
        LineConfidenceAvg: DWORD;          // Average of all DSP confidence results for this pin
        BytesOutput: DWORD;                // Bytes sent downstream
    end;
    PVBICODECFILTERING_STATISTICS_COMMON_PIN = ^TVBICODECFILTERING_STATISTICS_COMMON_PIN;


    // Codec-specific statistics - NABTS


    TVBICODECFILTERING_STATISTICS_NABTS = record
        Common: TVBICODECFILTERING_STATISTICS_COMMON; // Generic VBI statistics
        FECBundleBadLines: DWORD;          // Un-FEC-correctable lines
        FECQueueOverflows: DWORD;          // Number of times FEC queue overflowed
        FECCorrectedLines: DWORD;          // Lines CSUM corrected by FEC
        FECUncorrectableLines: DWORD;      // FEC input lines not CSUM correctable
        BundlesProcessed: DWORD;           // Bundles received from FEC
        BundlesSent2IP: DWORD;             // Bundles sent to IP driver
        FilteredLines: DWORD;              // Lines processed and then dropped
        // because no one was interested
    end;
    PVBICODECFILTERING_STATISTICS_NABTS = ^TVBICODECFILTERING_STATISTICS_NABTS;

    TVBICODECFILTERING_STATISTICS_NABTS_PIN = record
        Common: TVBICODECFILTERING_STATISTICS_COMMON_PIN;// Generic VBI pin statistics
    end;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN = ^TVBICODECFILTERING_STATISTICS_NABTS_PIN;


    // Codec-specific statistics - Closed Caption


    TVBICODECFILTERING_STATISTICS_CC = record
        Common: TVBICODECFILTERING_STATISTICS_COMMON; // Generic VBI statistics
    end;
    PVBICODECFILTERING_STATISTICS_CC = ^TVBICODECFILTERING_STATISTICS_CC;


    TVBICODECFILTERING_STATISTICS_CC_PIN = record
        Common: TVBICODECFILTERING_STATISTICS_COMMON_PIN;// Generic VBI pin statistics
    end;
    PVBICODECFILTERING_STATISTICS_CC_PIN = ^TVBICODECFILTERING_STATISTICS_CC_PIN;

    //{$if (NTDDI_VERSION >= NTDDI_WINXP)}


    // Codec-specific statistics - Teletext


    TVBICODECFILTERING_STATISTICS_TELETEXT = record
        Common: TVBICODECFILTERING_STATISTICS_COMMON; // Generic VBI statistics
    end;
    PVBICODECFILTERING_STATISTICS_TELETEXT = ^TVBICODECFILTERING_STATISTICS_TELETEXT;

    TVBICODECFILTERING_STATISTICS_TELETEXT_PIN = record
        Common: TVBICODECFILTERING_STATISTICS_COMMON_PIN;// Generic VBI pin statistics
    end;
    PVBICODECFILTERING_STATISTICS_TELETEXT_PIN = ^TVBICODECFILTERING_STATISTICS_TELETEXT_PIN;

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    ////////////////////////////////////////////////////////////////////////////
    // VBI codec property structures(based on KSPROPERTY_VBICODECFILTERING enum)
    ////////////////////////////////////////////////////////////////////////////

    // *** Most codecs support this property
    //    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
    //    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
    TKSPROPERTY_VBICODECFILTERING_SCANLINES_S = record
        _Property: TKSPROPERTY;
        Scanlines: TVBICODECFILTERING_SCANLINES;
    end;
    PKSPROPERTY_VBICODECFILTERING_SCANLINES_S = ^TKSPROPERTY_VBICODECFILTERING_SCANLINES_S;

    // *** NABTS codecs support this property
    //    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    //    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    TKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S = record
        _Property: TKSPROPERTY;
        Substreams: TVBICODECFILTERING_NABTS_SUBSTREAMS;
    end;
    PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S = ^TKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

    // *** Closed captioning codecs support this property
    //    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    //    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    TKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S = record
        _Property: TKSPROPERTY;
        Substreams: TVBICODECFILTERING_CC_SUBSTREAMS;
    end;
    PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S = ^TKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

    // *** Most codecs support these versions of the global and pin properties
    //    KSPROPERTY_VBICODECFILTERING_STATISTICS
    TKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S = record
        _Property: TKSPROPERTY;
        Statistics: TVBICODECFILTERING_STATISTICS_COMMON;
    end;
    PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S = ^TKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

    TKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S = record
        _Property: TKSPROPERTY;
        Statistics: TVBICODECFILTERING_STATISTICS_COMMON_PIN;
    end;
    PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S = ^TKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

    // *** NABTS codecs support this version of the global and pin properties
    //    KSPROPERTY_VBICODECFILTERING_STATISTICS
    TKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S = record
        _Property: TKSPROPERTY;
        Statistics: TVBICODECFILTERING_STATISTICS_NABTS;
    end;
    PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S = ^TKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

    TKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S = record
        _Property: TKSPROPERTY;
        Statistics: TVBICODECFILTERING_STATISTICS_NABTS_PIN;
    end;
    PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S = ^TKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

    // *** Closed captioning codecs support this version of the global and pin properties
    //    KSPROPERTY_VBICODECFILTERING_STATISTICS

    TKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S = record
        _Property: TKSPROPERTY;
        Statistics: TVBICODECFILTERING_STATISTICS_CC;
    end;
    PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S = ^TKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

    TKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S = record
        _Property: TKSPROPERTY;
        Statistics: TVBICODECFILTERING_STATISTICS_CC_PIN;
    end;
    PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S = ^TKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;



    // KSPROPSETID_VIDMEM_TRANSPORT related guids, structs and enums
    //===========================================================================


    // Capture MemoryAllocationFlags

    TCAPTURE_MEMORY_ALLOCATION_FLAGS = (
        KS_CAPTURE_ALLOC_INVALID = 0,
        KS_CAPTURE_ALLOC_SYSTEM = $0001,  // surface in system memory
        KS_CAPTURE_ALLOC_VRAM = $0002,  // surface in display memory
        KS_CAPTURE_ALLOC_SYSTEM_AGP = $0004,  // surface in system memory tagged as AGP accessible
        KS_CAPTURE_ALLOC_VRAM_MAPPED = $0008,  // surface in system memory mapped into VRAM address space
        KS_CAPTURE_ALLOC_SECURE_BUFFER = $0010   // secure buffer in VTL1
        );
    PCAPTURE_MEMORY_ALLOCATION_FLAGS = ^TCAPTURE_MEMORY_ALLOCATION_FLAGS;



    TKSPROPERTY_VIDMEM_TRANSPORT = (

        // enum value '0' means an invalid KSPROPERTY request.
        // Drivers should return an error.

        KSPROPERTY_DISPLAY_ADAPTER_GUID = 1,                        //Returns the Adapter GUID.
        KSPROPERTY_PREFERRED_CAPTURE_SURFACE,                       //Returns the memory surface preferred by that pin
        KSPROPERTY_CURRENT_CAPTURE_SURFACE,                         //Sets/Gets currently selected capture surface
        KSPROPERTY_MAP_CAPTURE_HANDLE_TO_VRAM_ADDRESS       //Maps VRAM surface handle to VRAM physical address
        );




    //Surface info passed on to the mini driver.

    TVRAM_SURFACE_INFO = record
        hSurface: UINT_PTR;
        VramPhysicalAddress: LONGLONG;
        cbCaptured: DWORD;
        dwWidth: DWORD;
        dwHeight: DWORD;
        dwLinearSize: DWORD;
        lPitch: LONG;
        ullReserved: array[0..15] of ULONGLONG;
    end;
    PVRAM_SURFACE_INFO = ^TVRAM_SURFACE_INFO;

    TVRAM_SURFACE_INFO_PROPERTY_S = record
        _Property: TKSPROPERTY;
        pVramSurfaceInfo: PVRAM_SURFACE_INFO;
    end;
    PVRAM_SURFACE_INFO_PROPERTY_S = ^TVRAM_SURFACE_INFO_PROPERTY_S;


    //Secure buffer info passed on to the mini driver.

    TSECURE_BUFFER_INFO = record
        guidBufferIdentifier: TGUID;
        cbBufferSize: DWORD;
        cbCaptured: DWORD;
        ullReserved: array [0..15] of ULONGLONG;
    end;
    PSECURE_BUFFER_INFO = ^TSECURE_BUFFER_INFO;




    TKSPROPERTY_MPEG4_MEDIATYPE_ATTRIBUTES = (
        KSPROPERTY_MPEG4_MEDIATYPE_SD_BOX = 1);

    TKSEVENT_DYNAMICFORMATCHANGE = (
        KSEVENT_DYNAMIC_FORMAT_CHANGE = 0);




    TKS_FRAME_INFO = record
        ExtendedHeaderSize: ULONG; // Size of this extended header
        dwFrameFlags: DWORD;       // Field1, Field2, or Frame
        PictureNumber: LONGLONG;
        DropCount: LONGLONG;

        // The following are only set when using OverlayMixer
        hDirectDraw: THANDLE;        // user mode DDraw handle
        hSurfaceHandle: THANDLE;     // user mode surface handle
        DirectDrawRect: TRECT;     // portion of surface locked
        case integer of
            0: (lSurfacePitch: LONG;
                Reserved2: DWORD;
                case integer of
                    0: (
                    Reserved3: DWORD;
                    Reserved4: DWORD);

                    1: (FrameCompletionNumber: ULONGLONG));

            // Contains surface pitch a.k.a stride
            1: (Reserved1: DWORD);
    end;
    PKS_FRAME_INFO = ^TKS_FRAME_INFO;



    TKS_VBI_FRAME_INFO = record
        ExtendedHeaderSize: ULONG; // Size of this extended header
        dwFrameFlags: DWORD;  // Field1, Field2, or Frame; & etc
        PictureNumber: LONGLONG; // Test only?
        DropCount: LONGLONG;     // Test only?
        dwSamplingFrequency: DWORD;
        TvTunerChangeInfo: TKS_TVTUNER_CHANGE_INFO;
        VBIInfoHeader: TKS_VBIINFOHEADER;

        //The following are for VRAM surface transport to support LDDM Capture

        //VRAM_SURFACE_INFO             VramSurfaceInfo;
    end;
    PKS_VBI_FRAME_INFO = ^TKS_VBI_FRAME_INFO;




    //===========================================================================
    // Analog video formats, used with:
    //      Analog Video Decoders
    //      TVTuners
    //      Analog Video Encoders

    // XXX_STANDARDS_SUPPORTED returns a bitmask
    //===========================================================================

    TKS_AnalogVideoStandard = (
        KS_AnalogVideo_None = $00000000,  // This is a digital sensor
        KS_AnalogVideo_NTSC_M = $00000001,  //        75 IRE Setup
        KS_AnalogVideo_NTSC_M_J = $00000002,  // Japan,  0 IRE Setup
        KS_AnalogVideo_NTSC_433 = $00000004,

        KS_AnalogVideo_PAL_B = $00000010,
        KS_AnalogVideo_PAL_D = $00000020,
        KS_AnalogVideo_PAL_G = $00000040,
        KS_AnalogVideo_PAL_H = $00000080,
        KS_AnalogVideo_PAL_I = $00000100,
        KS_AnalogVideo_PAL_M = $00000200,
        KS_AnalogVideo_PAL_N = $00000400,

        KS_AnalogVideo_PAL_60 = $00000800,

        KS_AnalogVideo_SECAM_B = $00001000,
        KS_AnalogVideo_SECAM_D = $00002000,
        KS_AnalogVideo_SECAM_G = $00004000,
        KS_AnalogVideo_SECAM_H = $00008000,
        KS_AnalogVideo_SECAM_K = $00010000,
        KS_AnalogVideo_SECAM_K1 = $00020000,
        KS_AnalogVideo_SECAM_L = $00040000,
        KS_AnalogVideo_SECAM_L1 = $00080000

        //{$if (NTDDI_VERSION >= NTDDI_WINXP)}
        , KS_AnalogVideo_PAL_N_COMBO = $00100000
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

        );



    //===========================================================================
    // Property set definitions
    // The comments show whether a given property is:
    //      R  : READ only
    //      w  : WRITE only
    //      RW : READ / WRITE
    //      O  : Optional (return E_UNSUPPORTED if you don't handle this)
    //===========================================================================


    TKSPROPERTY_ALLOCATOR_CONTROL = (
        KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,      // R O (will allocate exactly this number of buffers)
        KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE      // R O (return 2 DWORDs specifying surface size)

        //{$if (NTDDI_VERSION >= NTDDI_WINXP)}

        // W I (informn a capture driver whether interleave capture is possible or
        //      not - a value of 1 means that interleaved capture is supported)
        , KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS

        // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
        //      flag thus allowing interleaved capture of the video)
        , KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE

        // {$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)
        );


    //{$if (NTDDI_VERSION >= NTDDI_WINXP)

    TKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S = record
        //KSPROPERTY Property;
        CX: ULONG;
        CY: ULONG;
    end;
    PKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S = ^TKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S;

    TKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S = record
        //KSPROPERTY Property;
        InterleavedCapSupported: ULONG;
    end;
    PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S = ^TKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;


    TKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S = record
        //KSPROPERTY Property;
        InterleavedCapPossible: ULONG;
    end;
    PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S = ^TKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

    //===========================================================================



    TKSPROPERTY_VIDCAP_VIDEOPROCAMP = (
        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,                 // RW O
        KSPROPERTY_VIDEOPROCAMP_CONTRAST,                   // RW O
        KSPROPERTY_VIDEOPROCAMP_HUE,                        // RW O
        KSPROPERTY_VIDEOPROCAMP_SATURATION,                 // RW O
        KSPROPERTY_VIDEOPROCAMP_SHARPNESS,                  // RW O
        KSPROPERTY_VIDEOPROCAMP_GAMMA,                      // RW O
        KSPROPERTY_VIDEOPROCAMP_COLORENABLE,                // RW O
        KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,               // RW O
        KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION      // RW O

        //{$if (NTDDI_VERSION >= NTDDI_WINXP)

        , KSPROPERTY_VIDEOPROCAMP_GAIN                      // RW O

        //#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

        , KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER        // RW O
        , KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER_LIMIT  // RW O
        , KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE_COMPONENT    // RW O
        , KSPROPERTY_VIDEOPROCAMP_POWERLINE_FREQUENCY       // RW O

        //{$ENDIF} // XP SP2 and later (chronologically)

        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXP)

        );

    TKSPROPERTY_VIDEOPROCAMP_S = record
        _Property: TKSPROPERTY;
        Value: LONG;                       // Value to set or get
        Flags: ULONG;                       // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
        Capabilities: ULONG;                // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    end;
    PKSPROPERTY_VIDEOPROCAMP_S = ^TKSPROPERTY_VIDEOPROCAMP_S;

    //$if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    TKSPROPERTY_VIDEOPROCAMP_NODE_S = record
        NodeProperty: TKSP_NODE;
        Value: LONG;                        // Value to set or get
        Flags: ULONG;                        // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
        Capabilities: ULONG;                 // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    end;
    PKSPROPERTY_VIDEOPROCAMP_NODE_S = ^TKSPROPERTY_VIDEOPROCAMP_NODE_S;

    TKSPROPERTY_VIDEOPROCAMP_S2 = record
        _Property: TKSPROPERTY;
        Value1: LONG;
        Flags: ULONG;
        Capabilities: ULONG;
        Value2: LONG;
    end;
    PKSPROPERTY_VIDEOPROCAMP_S2 = ^TKSPROPERTY_VIDEOPROCAMP_S2;

    TKSPROPERTY_VIDEOPROCAMP_NODE_S2 = record
        NodeProperty: TKSP_NODE;
        Value1: LONG;
        Flags: ULONG;
        Capabilities: ULONG;
        Value2: LONG;
    end;
    PKSPROPERTY_VIDEOPROCAMP_NODE_S2 = ^TKSPROPERTY_VIDEOPROCAMP_NODE_S2;

    //{$ENDIF} // XP SP2 and later (chronologically)


    //$if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)
    TKSPROPERTY_VIDCAP_SELECTOR = (
        KSPROPERTY_SELECTOR_SOURCE_NODE_ID,              // RW
        KSPROPERTY_SELECTOR_NUM_SOURCES                  // R
        );
    PKSPROPERTY_VIDCAP_SELECTOR = ^TKSPROPERTY_VIDCAP_SELECTOR;

    TKSPROPERTY_SELECTOR_S = record
        _Property: TKSPROPERTY;
        Value: LONG;                        // Value to set or get
        Flags: ULONG;
        Capabilities: ULONG;
    end;
    PKSPROPERTY_SELECTOR_S = ^TKSPROPERTY_SELECTOR_S;

    TKSPROPERTY_SELECTOR_NODE_S = record
        NodeProperty: TKSP_NODE;
        Value: LONG;                        // Value to set or get
        Flags: ULONG;
        Capabilities: ULONG;
    end;
    PKSPROPERTY_SELECTOR_NODE_S = ^TKSPROPERTY_SELECTOR_NODE_S;

    //{$ENDIF} // XP SP2 and later (chronologically)

    TKSPROPERTY_TUNER = (
        KSPROPERTY_TUNER_CAPS,              // R  -overall device capabilities
        KSPROPERTY_TUNER_MODE_CAPS,         // R  -capabilities in this mode
        KSPROPERTY_TUNER_MODE,              // RW -set a mode (TV, FM, AM, DSS)
        KSPROPERTY_TUNER_STANDARD,          // R  -get TV standard (only if TV mode)
        KSPROPERTY_TUNER_FREQUENCY,         // RW -set/get frequency
        KSPROPERTY_TUNER_INPUT,             // RW -select an input
        KSPROPERTY_TUNER_STATUS,            // R  -tuning status
        KSPROPERTY_TUNER_IF_MEDIUM,         // R O-Medium for IF or Transport Pin
        KSPROPERTY_TUNER_SCAN_CAPS,         // R  -overall device capabilities for scanning
        KSPROPERTY_TUNER_SCAN_STATUS,       // R  -status of scan
        KSPROPERTY_TUNER_STANDARD_MODE,     // RW -autodetect mode for signal standard
        KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS // R -network type specific tuner capabilities
        );



    // Tuning support definitions and interfaces


    // Definitions

    TKSPROPERTY_TUNER_MODES = (
        KSPROPERTY_TUNER_MODE_TV = $0001,
        KSPROPERTY_TUNER_MODE_FM_RADIO = $0002,
        KSPROPERTY_TUNER_MODE_AM_RADIO = $0004,
        KSPROPERTY_TUNER_MODE_DSS = $0008,
        KSPROPERTY_TUNER_MODE_ATSC = $0010  // also used for DVB-T, DVB-C
        );

    // Describes how the device tunes.  Only one of these flags may be set
    // in KSPROPERTY_TUNER_MODE_CAPS_S.Strategy

    // Describe how the driver should attempt to tune:
    // EXACT:   just go to the frequency specified (no fine tuning)
    // FINE:    (slow) do an exhaustive search for the best signal
    // COARSE:  (fast) use larger frequency jumps to just determine if any signal

    TKS_TUNER_TUNING_FLAGS = (
        KS_TUNER_TUNING_EXACT = 1,        // No fine tuning
        KS_TUNER_TUNING_FINE,             // Fine grained search
        KS_TUNER_TUNING_COARSE           // Coarse search
        );

    TKS_TUNER_STRATEGY = (
        KS_TUNER_STRATEGY_PLL = $01, // Tune by PLL offset
        KS_TUNER_STRATEGY_SIGNAL_STRENGTH = $02, // Tune by signal strength
        KS_TUNER_STRATEGY_DRIVER_TUNES = $04 // Driver does fine tuning
        );


    // Tuning operations

    TKSPROPERTY_TUNER_CAPS_S = record
        _Property: TKSPROPERTY;
        ModesSupported: ULONG;              // KS_PROPERTY_TUNER_MODES_*
        VideoMedium: TKSPIN_MEDIUM;           // GUID_NULL (no pin), or GUID
        TVAudioMedium: TKSPIN_MEDIUM;         // GUID_NULL (no pin), or GUID
        RadioAudioMedium: TKSPIN_MEDIUM;      // GUID_NULL (no pin), or GUID
    end;
    PKSPROPERTY_TUNER_CAPS_S = ^TKSPROPERTY_TUNER_CAPS_S;

    TKSPROPERTY_TUNER_IF_MEDIUM_S = record
        _Property: TKSPROPERTY;
        IFMedium: TKSPIN_MEDIUM;              // GUID_NULL (no pin), or GUID
    end;
    PKSPROPERTY_TUNER_IF_MEDIUM_S = ^TKSPROPERTY_TUNER_IF_MEDIUM_S;

    TKSPROPERTY_TUNER_MODE_CAPS_S = record
        _Property: TKSPROPERTY;
        Mode: ULONG;                        // IN: KSPROPERTY_TUNER_MODE
        StandardsSupported: ULONG;          // KS_AnalogVideo_* (if TV or DSS)
        MinFrequency: ULONG;                // Hz
        MaxFrequency: ULONG;                // Hz
        TuningGranularity: ULONG;           // Hz
        NumberOfInputs: ULONG;              // count of inputs
        SettlingTime: ULONG;                // milliSeconds
        Strategy: ULONG;                    // KS_TUNER_STRATEGY
    end;
    PKSPROPERTY_TUNER_MODE_CAPS_S = ^TKSPROPERTY_TUNER_MODE_CAPS_S;

    TKSPROPERTY_TUNER_MODE_S = record
        _Property: TKSPROPERTY;
        Mode: ULONG;                        // IN: KSPROPERTY_TUNER_MODE
    end;
    PKSPROPERTY_TUNER_MODE_S = ^TKSPROPERTY_TUNER_MODE_S;

    TKSPROPERTY_TUNER_FREQUENCY_S = record
        _Property: TKSPROPERTY;
        Frequency: ULONG;                   // Hz
        LastFrequency: ULONG;               // Hz (last known good)
        TuningFlags: ULONG;                 // KS_TUNER_TUNING_FLAGS
        VideoSubChannel: ULONG;             // DSS
        AudioSubChannel: ULONG;             // DSS
        Channel: ULONG;                     // VBI decoders
        Country: ULONG;                     // VBI decoders
    end;
    PKSPROPERTY_TUNER_FREQUENCY_S = ^TKSPROPERTY_TUNER_FREQUENCY_S;

    TKSPROPERTY_TUNER_STANDARD_S = record
        _Property: TKSPROPERTY;
        Standard: ULONG;                    // KS_AnalogVideo_*
    end;
    PKSPROPERTY_TUNER_STANDARD_S = ^TKSPROPERTY_TUNER_STANDARD_S;

    TKSPROPERTY_TUNER_STANDARD_MODE_S = record
        _Property: TKSPROPERTY;
        AutoDetect: longbool;
        // RW - specifies whether the driver is in auto-detect mode for the signal standard
    end;
    PKSPROPERTY_TUNER_STANDARD_MODE_S = ^TKSPROPERTY_TUNER_STANDARD_MODE_S;

    TKSPROPERTY_TUNER_INPUT_S = record
        _Property: TKSPROPERTY;
        InputIndex: ULONG;                  // 0 to (n-1) inputs
    end;
    PKSPROPERTY_TUNER_INPUT_S = ^TKSPROPERTY_TUNER_INPUT_S;

    TKSPROPERTY_TUNER_STATUS_S = record
        _Property: TKSPROPERTY;
        CurrentFrequency: ULONG;            // Hz
        PLLOffset: ULONG;                   // if Strategy.KS_TUNER_STRATEGY_PLL
        SignalStrength: ULONG;              // if Stretegy.KS_TUNER_STRATEGY_SIGNAL_STRENGTH
        Busy: ULONG;                        // TRUE if in the process of tuning
    end;
    PKSPROPERTY_TUNER_STATUS_S = ^TKSPROPERTY_TUNER_STATUS_S;



    // Exhaustive Scanning tuner support definitions and interfaces


    // Definitions

    TTunerDecoderLockType = (
        Tuner_LockType_None = $00,   // Not locked on a signal. Can be returned at end of scan.
        Tuner_LockType_Within_Scan_Sensing_Range = $01,
        // Signal is near by, not able to report exact frequency. Can be returned at end of scan.
        Tuner_LockType_Locked =
        $02    // Fine tune signal lock established. Can be returned at end of scan.
        );
    TTunerLockType = TTunerDecoderLockType;



    // Data structures returned for KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S operations

    TTUNER_ANALOG_CAPS_S = record
        Mode: ULONG;                        // IN -KSPROPERTY_TUNER_MODE
        StandardsSupported: ULONG;          // KS_AnalogVideo_* (defined in KS_AnalogVideoStandard)
        MinFrequency: ULONG;                // R -Hz
        MaxFrequency: ULONG;                // R -Hz
        TuningGranularity: ULONG;           // R -Hz
        SettlingTime: ULONG;                // R -milliSeconds
        ScanSensingRange: ULONG;            // R -max range (Hz) in which tuner can detect presence of a signal
        FineTuneSensingRange: ULONG;        // R -max range (Hz) in which tuner can detect actual frequency of a signal
    end;
    PTUNER_ANALOG_CAPS_S = ^TTUNER_ANALOG_CAPS_S;

    // ...
    // More to come if new structures are needed for different network types.


    TKSEVENT_TUNER = (
        KSEVENT_TUNER_CHANGED,
        KSEVENT_TUNER_INITIATE_SCAN    // initiate frequency scan
        );


    // Exhaustive Scanning operations

    // Determine if ES is possible with device
    TKSPROPERTY_TUNER_SCAN_CAPS_S = record
        _Property: TKSPROPERTY;
        fSupportsHardwareAssistedScanning: longbool; // R
        SupportedBroadcastStandards: ULONG;      // R
        GUIDBucket: pointer;                       // RW
        lengthofBucket: ULONG;                   // R
    end;
    PKSPROPERTY_TUNER_SCAN_CAPS_S = ^TKSPROPERTY_TUNER_SCAN_CAPS_S;



    // Get specific network type capabilities structure (such as TUNER_ANALOG_CAPS_S for example)
    TKSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S = record
        _Property: TKSPROPERTY;
        NetworkType: TGUID;               // R  -one of the interested GUIDs returned in KSPROPERTY_TUNER_SCAN_CAPS_S
        BufferSize: ULONG;                // R  -size of the buffer;
        NetworkTunerCapabilities: pointer;  // RW -Buffer
    end;
    PKSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S = ^TKSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S;

    // Obtain current scan operation status
    TKSPROPERTY_TUNER_SCAN_STATUS_S = record
        _Property: TKSPROPERTY;
        LockStatus: TTunerLockType; // R -none, within scan sensing range, or locked
        CurrentFrequency: ULONG;   // R -current frequency
    end;
    PKSPROPERTY_TUNER_SCAN_STATUS_S = ^TKSPROPERTY_TUNER_SCAN_STATUS_S;

    // Start a scan
    TKSEVENT_TUNER_INITIATE_SCAN_S = record
        EventData: TKSEVENTDATA;
        StartFrequency: ULONG;          // W -initial frequency for the scan
        EndFrequency: ULONG;            // W -final frequency for the scan
    end;
    PKSEVENT_TUNER_INITIATE_SCAN_S = ^TKSEVENT_TUNER_INITIATE_SCAN_S;

    TKSPROPERTY_VIDCAP_VIDEOENCODER = (
        KSPROPERTY_VIDEOENCODER_CAPS,                       // R
        KSPROPERTY_VIDEOENCODER_STANDARD,                   // RW
        KSPROPERTY_VIDEOENCODER_COPYPROTECTION,             // RW O
        KSPROPERTY_VIDEOENCODER_CC_ENABLE                  // RW O
        );

    TKSPROPERTY_VIDEOENCODER_S = record
        _Property: TKSPROPERTY;
        Value: LONG;                   // value to get or set
        Flags: ULONG;
        Capabilities: ULONG;
    end;
    PKSPROPERTY_VIDEOENCODER_S = ^TKSPROPERTY_VIDEOENCODER_S;


    TKSPROPERTY_VIDCAP_VIDEODECODER = (
        KSPROPERTY_VIDEODECODER_CAPS,                       // R
        KSPROPERTY_VIDEODECODER_STANDARD,                   // RW
        KSPROPERTY_VIDEODECODER_STATUS,                     // R
        KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,              // Rw O
        KSPROPERTY_VIDEODECODER_VCR_TIMING,                 // RW O
        KSPROPERTY_VIDEODECODER_STATUS2                     // R
        );

    TKS_VIDEODECODER_FLAGS = (
        KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT = $0001, // VP Output can tri-stae
        KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = $0002, // VCR PLL timings
        KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = $0004 // Can indicate valid signal
        );

    TKSPROPERTY_VIDEODECODER_CAPS_S = record
        _Property: TKSPROPERTY;
        StandardsSupported: ULONG;      // KS_AnalogVideo_*
        Capabilities: ULONG;            // KS_VIDEODECODER_FLAGS_*
        SettlingTime: ULONG;            // milliseconds
        HSyncPerVSync: ULONG;           // Number of HSync Pulses per VSync
    end;
    PKSPROPERTY_VIDEODECODER_CAPS_S = ^TKSPROPERTY_VIDEODECODER_CAPS_S;

    TKSPROPERTY_VIDEODECODER_STATUS_S = record
        _Property: TKSPROPERTY;
        NumberOfLines: ULONG;           // 525 or 625 lines detected
        SignalLocked: ULONG;            // TRUE if signal is locked
    end;
    PKSPROPERTY_VIDEODECODER_STATUS_S = ^TKSPROPERTY_VIDEODECODER_STATUS_S;

    TKSPROPERTY_VIDEODECODER_STATUS2_S = record
        _Property: TKSPROPERTY;
        NumberOfLines: ULONG;       // R - 525 or 625 lines detected
        SignalLocked: ULONG;        // R - TRUE if signal is locked
        ChromaLock: ULONG;          // R - TRUE if a chroma signal is present
    end;
    PKSPROPERTY_VIDEODECODER_STATUS2_S = ^TKSPROPERTY_VIDEODECODER_STATUS2_S;

    TKSPROPERTY_VIDEODECODER_S = record
        _Property: TKSPROPERTY;
        Value: ULONG;                   // Get or set a value
    end;
    PKSPROPERTY_VIDEODECODER_S = ^TKSPROPERTY_VIDEODECODER_S;


    TKSEVENT_VIDEODECODER = (
        KSEVENT_VIDEODECODER_CHANGED);

    //===========================================================================

    // {$if (NTDDI_VERSION >= NTDDI_WIN8)}
    TKSEVENT_CAMERACONTROL = (
        KSEVENT_CAMERACONTROL_FOCUS,
        KSEVENT_CAMERACONTROL_ZOOM);
    // {$ENDIF}


    TKSPROPERTY_VIDCAP_CAMERACONTROL = (
        KSPROPERTY_CAMERACONTROL_PAN,                       // RW O
        KSPROPERTY_CAMERACONTROL_TILT,                      // RW O
        KSPROPERTY_CAMERACONTROL_ROLL,                      // RW O
        KSPROPERTY_CAMERACONTROL_ZOOM,                      // RW O
        KSPROPERTY_CAMERACONTROL_EXPOSURE,                  // RW O
        KSPROPERTY_CAMERACONTROL_IRIS,                      // RW O
        KSPROPERTY_CAMERACONTROL_FOCUS                      // RW O

        //$if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

        , KSPROPERTY_CAMERACONTROL_SCANMODE                 // RW O
        , KSPROPERTY_CAMERACONTROL_PRIVACY                  // RW O
        , KSPROPERTY_CAMERACONTROL_PANTILT                  // RW O
        , KSPROPERTY_CAMERACONTROL_PAN_RELATIVE             // RW O
        , KSPROPERTY_CAMERACONTROL_TILT_RELATIVE            // RW O
        , KSPROPERTY_CAMERACONTROL_ROLL_RELATIVE            // RW O
        , KSPROPERTY_CAMERACONTROL_ZOOM_RELATIVE            // RW O
        , KSPROPERTY_CAMERACONTROL_EXPOSURE_RELATIVE        // RW O
        , KSPROPERTY_CAMERACONTROL_IRIS_RELATIVE            // RW O
        , KSPROPERTY_CAMERACONTROL_FOCUS_RELATIVE           // RW O
        , KSPROPERTY_CAMERACONTROL_PANTILT_RELATIVE         // RW O
        , KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH             // R  O
        , KSPROPERTY_CAMERACONTROL_AUTO_EXPOSURE_PRIORITY   // RW O

        //{$ENDIF} // XP SP2 and later (chronologically)

        );

    //{$if (NTDDI_VERSION >= NTDDI_WIN8)}
    TKS_CameraControlAsyncOperation = (
        KS_CAMERACONTROL_ASYNC_START = $0001,
        KS_CAMERACONTROL_ASYNC_STOP = $0002,
        KS_CAMERACONTROL_ASYNC_RESET = $0003);

    TKSPROPERTY_CAMERACONTROL_S_EX = record
        _Property: TKSPROPERTY;
        Value: LONG;                   // value to get or set
        Flags: ULONG;                   // KSPROPERTY_CAMERACONTROL_FLAGS_*
        Capabilities: ULONG;            // KSPROPERTY_CAMERACONTROL_FLAGS_*
        FocusRect: TRECT;
    end;
    PKSPROPERTY_CAMERACONTROL_S_EX = ^TKSPROPERTY_CAMERACONTROL_S_EX;
    //{$ENDIF}

    TKSPROPERTY_CAMERACONTROL_S = record
        _Property: TKSPROPERTY;
        Value: LONG;                   // value to get or set
        Flags: ULONG;                   // KSPROPERTY_CAMERACONTROL_FLAGS_*
        Capabilities: ULONG;            // KSPROPERTY_CAMERACONTROL_FLAGS_*
    end;
    PKSPROPERTY_CAMERACONTROL_S = ^TKSPROPERTY_CAMERACONTROL_S;



    // $if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    TKSPROPERTY_CAMERACONTROL_NODE_S = record
        NodeProperty: TKSP_NODE;
        Value: LONG;                        // value to get or set
        Flags: ULONG;                        // KSPROPERTY_CAMERACONTROL_FLAGS_*
        Capabilities: ULONG;                 // KSPROPERTY_CAMERACONTROL_FLAGS_*
    end;
    PKSPROPERTY_CAMERACONTROL_NODE_S = ^TKSPROPERTY_CAMERACONTROL_NODE_S;

    TKSPROPERTY_CAMERACONTROL_S2 = record
        _Property: TKSPROPERTY;
        Value1: LONG;
        Flags: ULONG;
        Capabilities: ULONG;
        Value2: LONG;
    end;
    PKSPROPERTY_CAMERACONTROL_S2 = ^TKSPROPERTY_CAMERACONTROL_S2;

    TKSPROPERTY_CAMERACONTROL_NODE_S2 = record
        NodeProperty: TKSP_NODE;
        Value1: LONG;
        Flags: ULONG;
        Capabilities: ULONG;
        Value2: LONG;
    end;
    PKSPROPERTY_CAMERACONTROL_NODE_S2 = ^TKSPROPERTY_CAMERACONTROL_NODE_S2;

    TKSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S = record
        _Property: TKSPROPERTY;
        lOcularFocalLength: LONG;
        lObjectiveFocalLengthMin: LONG;
        lObjectiveFocalLengthMax: LONG;
    end;
    PKSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S = ^TKSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S;

    TKSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S = record
        NodeProperty: TKSNODEPROPERTY;
        lOcularFocalLength: LONG;
        lObjectiveFocalLengthMin: LONG;
        lObjectiveFocalLengthMax: LONG;
    end;
    PKSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S = ^TKSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S;

    // {$if (NTDDI_VERSION >= NTDDI_WIN8)}


    TKSPROPERTY_CAMERACONTROL_FLASH = (
        KSPROPERTY_CAMERACONTROL_FLASH_PROPERTY_ID = 0);



    TKSPROPERTY_CAMERACONTROL_FLASH_S = record
        Flash: ULONG;
        Capabilities: ULONG;
    end;
    PKSPROPERTY_CAMERACONTROL_FLASH_S = ^TKSPROPERTY_CAMERACONTROL_FLASH_S;



    TKSPROPERTY_CAMERACONTROL_VIDEO_STABILIZATION_MODE = (
        KSPROPERTY_CAMERACONTROL_VIDEO_STABILIZATION_MODE_PROPERTY_ID = 0);



    TKSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_S = record
        VideoStabilizationMode: ULONG;
        Capabilities: ULONG;
    end;
    PKSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_S = ^TKSPROPERTY_CAMERACONTROL_VIDEOSTABILIZATION_MODE_S;




    TKSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST = (
        KSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_PROPERTY_ID = 0);



    TKSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_S = record
        FocusRect: TRECT;
        AutoFocusLock: longbool;
        AutoExposureLock: longbool;
        AutoWhitebalanceLock: longbool;
        case integer of
            0: (Capabilities: ULONG);
            1: (Configuration: ULONG);

    end;
    PKSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_S = ^TKSPROPERTY_CAMERACONTROL_REGION_OF_INTEREST_S;

    TKSPROPERTY_CAMERACONTROL_IMAGE_PIN_CAPABILITY = (
        KSPROPERTY_CAMERACONTROL_IMAGE_PIN_CAPABILITY_PROPERTY_ID = 0);



    TKSPROPERTY_CAMERACONTROL_IMAGE_PIN_CAPABILITY_S = record
        Capabilities: ULONG;
        Reserved0: ULONG;
    end;
    PKSPROPERTY_CAMERACONTROL_IMAGE_PIN_CAPABILITY_S = ^TKSPROPERTY_CAMERACONTROL_IMAGE_PIN_CAPABILITY_S;



    //{$if (NTDDI_VERSION >= NTDDI_WIN8)
    TKSPROPERTY_CAMERACONTROL_EXTENDED_PROPERTY = (
        KSPROPERTY_CAMERACONTROL_EXTENDED_PHOTOMODE,                            // 0
        KSPROPERTY_CAMERACONTROL_EXTENDED_PHOTOFRAMERATE,                       // 1
        KSPROPERTY_CAMERACONTROL_EXTENDED_PHOTOMAXFRAMERATE,                    // 2
        KSPROPERTY_CAMERACONTROL_EXTENDED_PHOTOTRIGGERTIME,                     // 3
        KSPROPERTY_CAMERACONTROL_EXTENDED_WARMSTART,                            // 4
        KSPROPERTY_CAMERACONTROL_EXTENDED_MAXVIDFPS_PHOTORES,                   // 5
        KSPROPERTY_CAMERACONTROL_EXTENDED_PHOTOTHUMBNAIL,                       // 6
        KSPROPERTY_CAMERACONTROL_EXTENDED_SCENEMODE,                            // 7
        KSPROPERTY_CAMERACONTROL_EXTENDED_TORCHMODE,                            // 8
        KSPROPERTY_CAMERACONTROL_EXTENDED_FLASHMODE,                            // 9
        KSPROPERTY_CAMERACONTROL_EXTENDED_OPTIMIZATIONHINT,                     // 10
        KSPROPERTY_CAMERACONTROL_EXTENDED_WHITEBALANCEMODE,                     // 11
        KSPROPERTY_CAMERACONTROL_EXTENDED_EXPOSUREMODE,                         // 12
        KSPROPERTY_CAMERACONTROL_EXTENDED_FOCUSMODE,                            // 13
        KSPROPERTY_CAMERACONTROL_EXTENDED_ISO,                                  // 14
        KSPROPERTY_CAMERACONTROL_EXTENDED_FIELDOFVIEW,                          // 15
        KSPROPERTY_CAMERACONTROL_EXTENDED_EVCOMPENSATION,                       // 16
        KSPROPERTY_CAMERACONTROL_EXTENDED_CAMERAANGLEOFFSET,                    // 17
        //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)}
        KSPROPERTY_CAMERACONTROL_EXTENDED_METADATA,                             // 18
        KSPROPERTY_CAMERACONTROL_EXTENDED_FOCUSPRIORITY,                        // 19
        KSPROPERTY_CAMERACONTROL_EXTENDED_FOCUSSTATE,                           // 20
        KSPROPERTY_CAMERACONTROL_EXTENDED_ROI_CONFIGCAPS,                       // 21
        KSPROPERTY_CAMERACONTROL_EXTENDED_ROI_ISPCONTROL,                       // 22
        KSPROPERTY_CAMERACONTROL_EXTENDED_PHOTOCONFIRMATION,                    // 23
        KSPROPERTY_CAMERACONTROL_EXTENDED_ZOOM,                                 // 24
        KSPROPERTY_CAMERACONTROL_EXTENDED_MCC,                                  // 25
        KSPROPERTY_CAMERACONTROL_EXTENDED_ISO_ADVANCED,                         // 26
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)

        //{$if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)}
        KSPROPERTY_CAMERACONTROL_EXTENDED_VIDEOSTABILIZATION,                   // 27
        KSPROPERTY_CAMERACONTROL_EXTENDED_VFR,                                  // 28
        KSPROPERTY_CAMERACONTROL_EXTENDED_FACEDETECTION,                        // 29
        KSPROPERTY_CAMERACONTROL_EXTENDED_VIDEOHDR,                             // 30
        KSPROPERTY_CAMERACONTROL_EXTENDED_HISTOGRAM,                            // 31
        KSPROPERTY_CAMERACONTROL_EXTENDED_OIS,                                  // 32
        KSPROPERTY_CAMERACONTROL_EXTENDED_ADVANCEDPHOTO,                        // 33
        KSPROPERTY_CAMERACONTROL_EXTENDED_PROFILE,                              // 34
        //{$ENDIF}

        //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS1)}
        KSPROPERTY_CAMERACONTROL_EXTENDED_FACEAUTH_MODE,                        // 35
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS1)

        KSPROPERTY_CAMERACONTROL_EXTENDED_SECURE_MODE,                          // 36

        //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS3)}
        KSPROPERTY_CAMERACONTROL_EXTENDED_VIDEOTEMPORALDENOISING,               // 37
        //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS3)

        KSPROPERTY_CAMERACONTROL_EXTENDED_END,
        // All new controls must be before this!
        KSPROPERTY_CAMERACONTROL_EXTENDED_END2 = KSPROPERTY_CAMERACONTROL_EXTENDED_END);




    //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)}
    TKSEVENT_CAMERAEVENT = (
        KSEVENT_PHOTO_SAMPLE_SCANNED);
    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)



    TKSCAMERA_EXTENDEDPROP_WHITEBALANCE_MODE = (
        KSCAMERA_EXTENDEDPROP_WHITEBALANCE_TEMPERATURE = 1,
        KSCAMERA_EXTENDEDPROP_WHITEBALANCE_PRESET);

    TKSCAMERA_EXTENDEDPROP_WBPRESET = (
        KSCAMERA_EXTENDEDPROP_WBPRESET_CLOUDY = 1,
        KSCAMERA_EXTENDEDPROP_WBPRESET_DAYLIGHT,
        KSCAMERA_EXTENDEDPROP_WBPRESET_FLASH,
        KSCAMERA_EXTENDEDPROP_WBPRESET_FLUORESCENT,
        KSCAMERA_EXTENDEDPROP_WBPRESET_TUNGSTEN,
        KSCAMERA_EXTENDEDPROP_WBPRESET_CANDLELIGHT);



    TKSPROPERTY_CAMERA_PHOTOTRIGGERTIME_FLAGS = (
        KSPROPERTY_CAMERA_PHOTOTRIGGERTIME_CLEAR,
        KSPROPERTY_CAMERA_PHOTOTRIGGERTIME_SET);




    // Kernel Streaming Video node type definitions


    //{$if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)


    TKSCAMERA_EXTENDEDPROP_HEADER = record
        Version: ULONG;
        PinId: ULONG;
        Size: ULONG;
        Result: ULONG;
        Flags: ULONGLONG;
        Capability: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_HEADER = ^TKSCAMERA_EXTENDEDPROP_HEADER;

    TKSCAMERA_EXTENDEDPROP_VALUE = record
        case integer of // Value;
            0: (dbl: double);
            1: (ull: ULONGLONG);
            2: (ul: ULONG);
            3: (ratio: ULARGE_INTEGER);
            4: (l: LONG);
            5: (ll: LONGLONG);
    end;
    PKSCAMERA_EXTENDEDPROP_VALUE = ^TKSCAMERA_EXTENDEDPROP_VALUE;

    // This is the payload structure fo the Maximum video sensor frame rate possible
    // based on the photo resolution being programmed on the sensor.  The PhotoRes fields
    // are provided by the application, the preview/capture FPS fields are filled in
    // by the driver to indicate the maximum sensor frame rate.
    TKSCAMERA_MAXVIDEOFPS_FORPHOTORES = record
        PhotoResWidth: ULONG;
        PhotoResHeight: ULONG;
        PreviewFPSNum: ULONG;
        PreviewFPSDenom: ULONG;
        CaptureFPSNum: ULONG;
        CaptureFPSDenom: ULONG;
    end;
    PKSCAMERA_MAXVIDEOFPS_FORPHOTORES = ^TKSCAMERA_MAXVIDEOFPS_FORPHOTORES;




    TKSCAMERA_EXTENDEDPROP_PHOTOMODE = record
        RequestedHistoryFrames: ULONG;
        MaxHistoryFrames: ULONG;
        SubMode: ULONG;
        Reserved: ULONG;
    end;
    PKSCAMERA_EXTENDEDPROP_PHOTOMODE = ^TKSCAMERA_EXTENDEDPROP_PHOTOMODE;

    TKSCAMERA_EXTENDEDPROP_VIDEOPROCSETTING = record
        Mode: ULONG;
        Min: LONG;
        Max: LONG;
        Step: LONG;
        VideoProc: TKSCAMERA_EXTENDEDPROP_VALUE;
        Reserved: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_VIDEOPROCSETTING = ^TKSCAMERA_EXTENDEDPROP_VIDEOPROCSETTING;

    TKSCAMERA_EXTENDEDPROP_EVCOMPENSATION = record
        Mode: ULONG;
        Min: LONG;
        Max: LONG;
        Value: LONG;
        Reserved: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_EVCOMPENSATION = ^TKSCAMERA_EXTENDEDPROP_EVCOMPENSATION;

    TKSCAMERA_EXTENDEDPROP_FIELDOFVIEW = record
        NormalizedFocalLengthX: ULONG;
        NormalizedFocalLengthY: ULONG;
        Flag: ULONG;
        Reserved: ULONG;
    end;
    PKSCAMERA_EXTENDEDPROP_FIELDOFVIEW = ^TKSCAMERA_EXTENDEDPROP_FIELDOFVIEW;

    TKSCAMERA_EXTENDEDPROP_CAMERAOFFSET = record
        PitchAngle: LONG;
        YawAngle: LONG;
        Flag: ULONG;
        Reserved: ULONG;
    end;
    PKSCAMERA_EXTENDEDPROP_CAMERAOFFSET = ^TKSCAMERA_EXTENDEDPROP_CAMERAOFFSET;


    //{$if (NTDDI_VERSION >= NTDDI_WINBLUE)}

    // Metadata
    TKSCAMERA_EXTENDEDPROP_METADATAINFO = record
        BufferAlignment: LONG;         // Required alignment for metadata buffer
        MaxMetadataBufferSize: ULONG;   // Required metadata buffer size
    end;
    PKSCAMERA_EXTENDEDPROP_METADATAINFO = ^TKSCAMERA_EXTENDEDPROP_METADATAINFO;

    TKSCAMERA_EXTENDEDPROP_MetadataAlignment = (
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_16 = 4,                     // Aligned at 16 bytes
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_32,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_64,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_128,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_256,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_512,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_1024,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_2048,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_4096,
        KSCAMERA_EXTENDEDPROP_MetadataAlignment_8192);



    TKSCAMERA_MetadataId = (
        MetadataId_Standard_Start = 1,
        MetadataId_PhotoConfirmation = MetadataId_Standard_Start,
        MetadataId_UsbVideoHeader,
        MetadataId_CaptureStats,
        MetadataId_CameraExtrinsics,
        MetadataId_CameraIntrinsics,
        MetadataId_FrameIllumination,
        MetadataId_Standard_End = MetadataId_FrameIllumination,
        MetadataId_Custom_Start = $80000000);

    TKSCAMERA_METADATA_ITEMHEADER = record
        MetadataId: ULONG;
        Size: ULONG;         // Size of this header + metadata payload following
    end;
    PKSCAMERA_METADATA_ITEMHEADER = ^TKSCAMERA_METADATA_ITEMHEADER;

    TKSCAMERA_METADATA_PHOTOCONFIRMATION = record
        Header: TKSCAMERA_METADATA_ITEMHEADER;
        PhotoConfirmationIndex: ULONG;
        Reserved: ULONG;
    end;
    PKSCAMERA_METADATA_PHOTOCONFIRMATION = ^TKSCAMERA_METADATA_PHOTOCONFIRMATION;

    TKSCAMERA_METADATA_FRAMEILLUMINATION = record
        Header: TKSCAMERA_METADATA_ITEMHEADER;
        Flags: ULONG;
        Reserved: ULONG;
    end;
    PKSCAMERA_METADATA_FRAMEILLUMINATION = ^TKSCAMERA_METADATA_FRAMEILLUMINATION;



    TKSCAMERA_METADATA_CAPTURESTATS = record
        Header: TKSCAMERA_METADATA_ITEMHEADER;
        Flags: ULONG;
        Reserved: ULONG;
        ExposureTime: ULONGLONG;
        ExposureCompensationFlags: ULONGLONG;
        ExposureCompensationValue: LONG;
        IsoSpeed: ULONG;
        FocusState: ULONG;
        LensPosition: ULONG; // a.k.a Focus
        WhiteBalance: ULONG;
        Flash: ULONG;
        FlashPower: ULONG;
        ZoomFactor: ULONG;
        SceneMode: ULONGLONG;
        SensorFramerate: ULONGLONG;
    end;
    PKSCAMERA_METADATA_CAPTURESTATS = ^TKSCAMERA_METADATA_CAPTURESTATS;


    // Focus State
    TKSCAMERA_EXTENDEDPROP_FOCUSSTATE = (
        KSCAMERA_EXTENDEDPROP_FOCUSSTATE_UNINITIALIZED = 0,
        KSCAMERA_EXTENDEDPROP_FOCUSSTATE_LOST,
        KSCAMERA_EXTENDEDPROP_FOCUSSTATE_SEARCHING,
        KSCAMERA_EXTENDEDPROP_FOCUSSTATE_FOCUSED,
        KSCAMERA_EXTENDEDPROP_FOCUSSTATE_FAILED);

    // Extended ROI
    TKSCAMERA_EXTENDEDPROP_ROI_CONFIGCAPSHEADER = record
        Size: ULONG;                   // Size of this header + all _CONFIGCAPS structures followed
        ConfigCapCount: ULONG;         // Number of _CONFIGCAPS structures followed
        Reserved: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_CONFIGCAPSHEADER = ^TKSCAMERA_EXTENDEDPROP_ROI_CONFIGCAPSHEADER;

    TKSCAMERA_EXTENDEDPROP_ROI_CONFIGCAPS = record
        ControlId: ULONG;              // ISP control ID (focus, exposure, or white balance)
        MaxNumberOfROIs: ULONG;        // Max ROIs supported for this ISP control
        Capability: ULONGLONG;             // Caps for this ISP control
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_CONFIGCAPS = ^TKSCAMERA_EXTENDEDPROP_ROI_CONFIGCAPS;

    TKSCAMERA_EXTENDEDPROP_ROI_ISPCONTROLHEADER = record
        Size: ULONG;                   // Size of this header + all _ ISPCONTROL + all _RECTINFO
        ControlCount: ULONG;           // Number of ISP controls. 0 indicating clear all ROIs
        Reserved: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_ISPCONTROLHEADER = ^TKSCAMERA_EXTENDEDPROP_ROI_ISPCONTROLHEADER;

    TKSCAMERA_EXTENDEDPROP_ROI_ISPCONTROL = record
        ControlId: ULONG;              // ISP control ID (focus, exposure, or white balance)
        ROICount: ULONG;               // Number of ROIs associated with this ISP control
        Result: ULONG;                 // Error results of the last SET operation for this ISP control
        Reserved: ULONG;
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_ISPCONTROL = ^TKSCAMERA_EXTENDEDPROP_ROI_ISPCONTROL;

    TKSCAMERA_EXTENDEDPROP_ROI_INFO = record
        Region: TRECT;
        // Relative coordinates on the frame that face detection is running (Q31 format)
        Flags: ULONGLONG;
        // VIDEOPROCFLAG flags indicating the op mode for the ISP control. Default is 0 for focus
        Weight: LONG;                    // Weight of the region   (0 -100)
        RegionOfInterestType: LONG;
        // KSCAMERA_EXTENDEDPROP_ROITYPE_FACE, if the region is a face; Unknown otherwise
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_INFO = ^TKSCAMERA_EXTENDEDPROP_ROI_INFO;

    TKSCAMERA_EXTENDEDPROP_ROITYPE = (
        KSCAMERA_EXTENDEDPROP_ROITYPE_UNKNOWN = 0,
        KSCAMERA_EXTENDEDPROP_ROITYPE_FACE);

    TKSCAMERA_EXTENDEDPROP_ROI_WHITEBALANCE = record
        ROIInfo: TKSCAMERA_EXTENDEDPROP_ROI_INFO;   // Must be the first field
        Reserved: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_WHITEBALANCE = ^TKSCAMERA_EXTENDEDPROP_ROI_WHITEBALANCE;

    TKSCAMERA_EXTENDEDPROP_ROI_EXPOSURE = record
        ROIInfo: TKSCAMERA_EXTENDEDPROP_ROI_INFO;   // Must be the first field
        Reserved: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_EXPOSURE = ^TKSCAMERA_EXTENDEDPROP_ROI_EXPOSURE;

    TKSCAMERA_EXTENDEDPROP_ROI_FOCUS = record
        ROIInfo: TKSCAMERA_EXTENDEDPROP_ROI_INFO;   // Must be the first field
        Reserved: ULONGLONG;
    end;
    PKSCAMERA_EXTENDEDPROP_ROI_FOCUS = ^TKSCAMERA_EXTENDEDPROP_ROI_FOCUS;



    // Per Frame Settings
    TKSPROPERTY_CAMERACONTROL_PERFRAMESETTING_PROPERTY = (
        KSPROPERTY_CAMERACONTROL_PERFRAMESETTING_CAPABILITY = 0,
        KSPROPERTY_CAMERACONTROL_PERFRAMESETTING_SET,
        KSPROPERTY_CAMERACONTROL_PERFRAMESETTING_CLEAR);



    TKSCAMERA_PERFRAMESETTING_ITEM_TYPE = (
        KSCAMERA_PERFRAMESETTING_ITEM_EXPOSURE_TIME = 1,
        KSCAMERA_PERFRAMESETTING_ITEM_FLASH,
        KSCAMERA_PERFRAMESETTING_ITEM_EXPOSURE_COMPENSATION,
        KSCAMERA_PERFRAMESETTING_ITEM_ISO,
        KSCAMERA_PERFRAMESETTING_ITEM_FOCUS,
        KSCAMERA_PERFRAMESETTING_ITEM_PHOTOCONFIRMATION,
        KSCAMERA_PERFRAMESETTING_ITEM_CUSTOM);

    TKSCAMERA_PERFRAMESETTING_CAP_ITEM_HEADER = record
        Size: ULONG;
        _Type: ULONG;   // KSCAMERA_PERFRAMESETTING_ITEM_TYPE
        Flags: ULONGLONG;  // Supported Flags
    end;
    PKSCAMERA_PERFRAMESETTING_CAP_ITEM_HEADER = ^TKSCAMERA_PERFRAMESETTING_CAP_ITEM_HEADER;

    TKSCAMERA_PERFRAMESETTING_CAP_HEADER = record
        Size: ULONG;
        ItemCount: ULONG;
        Flags: ULONGLONG;
    end;
    PKSCAMERA_PERFRAMESETTING_CAP_HEADER = ^TKSCAMERA_PERFRAMESETTING_CAP_HEADER;

    TKSCAMERA_PERFRAMESETTING_CUSTOM_ITEM = record
        Size: ULONG;
        Reserved: ULONG;
        Id: TGUID;
    end;
    PKSCAMERA_PERFRAMESETTING_CUSTOM_ITEM = ^TKSCAMERA_PERFRAMESETTING_CUSTOM_ITEM;

    TKSCAMERA_PERFRAMESETTING_ITEM_HEADER = record
        Size: ULONG;
        _Type: ULONG;   // KSCAMERA_PERFRAMESETTING_ITEM_TYPE
        Flags: ULONGLONG;
    end;
    PKSCAMERA_PERFRAMESETTING_ITEM_HEADER = ^TKSCAMERA_PERFRAMESETTING_ITEM_HEADER;

    TKSCAMERA_PERFRAMESETTING_FRAME_HEADER = record
        Size: ULONG;
        Id: ULONG;
        ItemCount: ULONG;
        Reserved: ULONG;
    end;
    PKSCAMERA_PERFRAMESETTING_FRAME_HEADER = ^TKSCAMERA_PERFRAMESETTING_FRAME_HEADER;

    TKSCAMERA_PERFRAMESETTING_HEADER = record
        Size: ULONG;
        FrameCount: ULONG;
        Id: TGUID;
        Flags: ULONGLONG;
        LoopCount: ULONG;
        Reserved: ULONG;
    end;
    PKSCAMERA_PERFRAMESETTING_HEADER = ^TKSCAMERA_PERFRAMESETTING_HEADER;

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINBLUE)



    TKSCAMERA_EXTENDEDPROP_PROFILE = record
        ProfileId: TGUID;
        Index: UINT32;
        Reserved: UINT32;
    end;
    PKSCAMERA_EXTENDEDPROP_PROFILE = ^TKSCAMERA_EXTENDEDPROP_PROFILE;


    TKSCAMERA_PROFILE_MEDIAINFO = record
        Resolution: record
            X: UINT32;
            Y: UINT32;
        end;
        MaxFrameRate: record
            Numerator: UINT32;
            Denominator: UINT32;
        end;

        Flags: ULONGLONG;
        Data0: UINT32;
        Data1: UINT32;
        Data2: UINT32;
        Data3: UINT32;
    end;
    PKSCAMERA_PROFILE_MEDIAINFO = ^TKSCAMERA_PROFILE_MEDIAINFO;

    TKSCAMERA_PROFILE_PININFO = record
        PinCategory: TGUID;
        case integer of
            0: (PinIndex: USHORT;
                ProfileSensorType: USHORT;
                MediaInfoCount: UINT32;
                MediaInfos: PKSCAMERA_PROFILE_MEDIAINFO;
            );
            1: (Reserved: UINT32);

    end;
    PKSCAMERA_PROFILE_PININFO = ^TKSCAMERA_PROFILE_PININFO;

    TKSCAMERA_PROFILE_INFO = record
        ProfileId: TGUID;
        Index: UINT32;
        PinCount: UINT32;
        Pins: PKSCAMERA_PROFILE_PININFO;
    end;
    PKSCAMERA_PROFILE_INFO = ^TKSCAMERA_PROFILE_INFO;

    TKSCAMERA_PROFILE_CONCURRENCYINFO = record
        ReferenceGuid: TGUID;
        Reserved: UINT32;
        ProfileCount: UINT32;
        Profiles: PKSCAMERA_PROFILE_INFO;
    end;
    PKSCAMERA_PROFILE_CONCURRENCYINFO = ^TKSCAMERA_PROFILE_CONCURRENCYINFO;

    TKSDEVICE_PROFILE_INFO = record
        _Type: UINT32;
        Size: UINT32;
        case integer of
            0: (Camera: record

                    Info: TKSCAMERA_PROFILE_INFO;
                    Reserved: UINT32;
                    ConcurrencyCount: UINT32;
                    Concurrency: PKSCAMERA_PROFILE_CONCURRENCYINFO;
                end;
            );

        // Add other device type specific "profiles" here.

    end;
    PKSDEVICE_PROFILE_INFO = ^TKSDEVICE_PROFILE_INFO;


    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN8)


    TWNF_KSCAMERA_STREAMSTATE_INFO = record
        ProcessId: ULONG;
        SessionId: ULONG;
        StreamState: ULONG;
        Reserved: ULONG;
    end;
    PWNF_KSCAMERA_STREAMSTATE_INFO = ^TWNF_KSCAMERA_STREAMSTATE_INFO;

    TKSPROPERTY_EXTDEVICE = (
        KSPROPERTY_EXTDEVICE_ID,                // R
        KSPROPERTY_EXTDEVICE_VERSION,           // R
        KSPROPERTY_EXTDEVICE_POWER_STATE,       // RW
        KSPROPERTY_EXTDEVICE_PORT,              // R
        KSPROPERTY_EXTDEVICE_CAPABILITIES       // R
        );

    TDEVCAPS = record
        CanRecord: LONG;
        CanRecordStrobe: LONG;
        HasAudio: LONG;
        HasVideo: LONG;
        UsesFiles: LONG;
        CanSave: LONG;
        DeviceType: LONG;
        TCRead: LONG;
        TCWrite: LONG;
        CTLRead: LONG;
        IndexRead: LONG;
        Preroll: LONG;
        Postroll: LONG;
        SyncAcc: LONG;
        NormRate: LONG;
        CanPreview: LONG;
        CanMonitorSrc: LONG;
        CanTest: LONG;
        VideoIn: LONG;
        AudioIn: LONG;
        Calibrate: LONG;
        SeekType: LONG;
        SimulatedHardware: LONG;
    end;
    PDEVCAPS = ^TDEVCAPS;

    TKSPROPERTY_EXTDEVICE_S = record
        _Property: TKSPROPERTY;
        u: record
            case integer of
                0: (Capabilities: TDEVCAPS);          // Device capabilities
                1: (DevPort: ULONG);               // 1394, USB, etc.
                2: (PowerState: ULONG);            // On, standby or off
                3: (pawchString: array [0..MAX_PATH - 1] of WCHAR); // Version
                4: (NodeUniqueID: array [0..1] of DWORD);       // Unique NodeID
        end;
    end;
    PKSPROPERTY_EXTDEVICE_S = ^TKSPROPERTY_EXTDEVICE_S;

    TKSPROPERTY_EXTXPORT = (
        KSPROPERTY_EXTXPORT_CAPABILITIES,       // (R)  Transport specific capability
        KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,  // (RW) Input signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
        KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE, // (RW) Output signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
        KSPROPERTY_EXTXPORT_LOAD_MEDIUM,        // (RW) Eject, open tray, close tray
        KSPROPERTY_EXTXPORT_MEDIUM_INFO,        // (R)  Cassettte type, tape grade and write protection
        KSPROPERTY_EXTXPORT_STATE,              // (RW) Current transport mode and state
        KSPROPERTY_EXTXPORT_STATE_NOTIFY,       // (RW) Notify of transport mode and state change
        KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,    // (W)  Search to a specific timecode on a tape
        KSPROPERTY_EXTXPORT_ATN_SEARCH,         // (W)  Search to a specific absolute track number (ATN) on a tape
        KSPROPERTY_EXTXPORT_RTC_SEARCH,         // (W)  Search to a specific relative time counter (RTC) on a tape
        KSPROPERTY_RAW_AVC_CMD                  // (RW) Issue a raw AVC commnad
        );

    TTRANSPORTSTATUS = record
        Mode: LONG;
        LastError: LONG;
        RecordInhibit: LONG;
        ServoLock: LONG;
        MediaPresent: LONG;
        MediaLength: LONG;
        MediaSize: LONG;
        MediaTrackCount: LONG;
        MediaTrackLength: LONG;
        MediaTrackSide: LONG;
        MediaType: LONG;
        LinkMode: LONG;
        NotifyOn: LONG;
    end;
    PTRANSPORTSTATUS = ^TTRANSPORTSTATUS;

    TTRANSPORTBASICPARMS = record
        TimeFormat: LONG;
        TimeReference: LONG;
        Superimpose: LONG;
        EndStopAction: LONG;
        RecordFormat: LONG;
        StepFrames: LONG;
        SetpField: LONG;
        Preroll: LONG;
        RecPreroll: LONG;
        Postroll: LONG;
        EditDelay: LONG;
        PlayTCDelay: LONG;
        RecTCDelay: LONG;
        EditField: LONG;
        FrameServo: LONG;
        ColorFrameServo: LONG;
        ServoRef: LONG;
        WarnGenlock: LONG;
        SetTracking: LONG;
        VolumeName: array[0..39] of TCHAR;
        Ballistic: array[0..19] of LONG;
        Speed: LONG;
        CounterFormat: LONG;
        TunerChannel: LONG;
        TunerNumber: LONG;
        TimerEvent: LONG;
        TimerStartDay: LONG;
        TimerStartTime: LONG;
        TimerStopDay: LONG;
        TimerStopTime: LONG;
    end;
    PTRANSPORTBASICPARMS = ^TTRANSPORTBASICPARMS;

    TTRANSPORTVIDEOPARMS = record
        OutputMode: LONG;
        Input: LONG;
    end;
    PTRANSPORTVIDEOPARMS = ^TTRANSPORTVIDEOPARMS;

    TTRANSPORTAUDIOPARMS = record
        EnableOutput: LONG;
        EnableRecord: LONG;
        EnableSelsync: LONG;
        Input: LONG;
        MonitorSource: LONG;
    end;
    PTRANSPORTAUDIOPARMS = ^TTRANSPORTAUDIOPARMS;

    TMEDIUM_INFO = record
        MediaPresent: longbool;
        MediaType: ULONG;
        RecordInhibit: longbool;
    end;
    PMEDIUM_INFO = ^TMEDIUM_INFO;

    TTRANSPORT_STATE = record
        Mode: ULONG;
        State: ULONG;
    end;
    PTRANSPORT_STATE = ^TTRANSPORT_STATE;

    TKSPROPERTY_EXTXPORT_S = record
        _Property: TKSPROPERTY;
        u: record
            case integer of
                0: (Capabilities: ULONG);
                1: (SignalMode: ULONG);
                2: (LoadMedium: ULONG);
                3: (MediumInfo: TMEDIUM_INFO);
                4: (XPrtState: TTRANSPORT_STATE);
                5: (Timecode: record
                        frame: byte;
                        second: byte;
                        minute: byte;
                        hour: byte;
                    end;);
                6: (dwTimecode: DWORD);
                7: (dwAbsTrackNumber: DWORD);
                8: (RawAVC: record
                        PayloadSize: ULONG;
                        Payload: array [0..511] of byte;
                    end;);
        end;

    end;
    PKSPROPERTY_EXTXPORT_S = ^TKSPROPERTY_EXTXPORT_S;

    TKSPROPERTY_EXTXPORT_NODE_S = record
        NodeProperty: TKSP_NODE;
        u: record
            case integer of
                0: (Capabilities: ULONG);
                1: (SignalMode: ULONG);
                2: (LoadMedium: ULONG);
                3: (MediumInfo: TMEDIUM_INFO);
                4: (XPrtState: TTRANSPORT_STATE);
                5: (Timecode: record
                        frame: byte;
                        second: byte;
                        minute: byte;
                        hour: byte;
                    end;);
                6: (dwTimecode: DWORD);
                7: (dwAbsTrackNumber: DWORD);
                8: (RawAVC: record
                        PayloadSize: ULONG;
                        Payload: array[0..511] of byte;
                    end;)
        end;

    end;
    PKSPROPERTY_EXTXPORT_NODE_S = ^TKSPROPERTY_EXTXPORT_NODE_S;



    TKSPROPERTY_TIMECODE = (
        KSPROPERTY_TIMECODE_READER,  // (R) Timecode for the current tape position
        KSPROPERTY_ATN_READER,       // (R) Absolute track number for the current tape position
        KSPROPERTY_RTC_READER        // (R) Relative time counter for the current tape position
        );


    TTIMECODE = record
        wFrameRate: word;
        wFrameFract: word;
        dwFrames: DWORD;

        qw: DWORDLONG;
    end;
    PTIMECODE = ^TTIMECODE;

    TTIMECODE_SAMPLE = record
        qwTick: LONGLONG;
        timecode: TTIMECODE;
        dwUser: DWORD;
        dwFlags: DWORD;
    end;

    PTIMECODE_SAMPLE = ^TTIMECODE_SAMPLE;



    TKSPROPERTY_TIMECODE_S = record
        _Property: TKSPROPERTY;
        TimecodeSamp: TTIMECODE_SAMPLE;
    end;
    PKSPROPERTY_TIMECODE_S = ^TKSPROPERTY_TIMECODE_S;

    TKSPROPERTY_TIMECODE_NODE_S = record
        NodeProperty: TKSP_NODE;
        TimecodeSamp: TTIMECODE_SAMPLE;
    end;
    PKSPROPERTY_TIMECODE_NODE_S = ^TKSPROPERTY_TIMECODE_NODE_S;

    TKSEVENT_DEVCMD = (
        KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,     // Final response is ready for notify command
        KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,    // Final response is ready for control command.
        KSEVENT_EXTDEV_COMMAND_BUSRESET,                 // A bus reset has occured.
        KSEVENT_EXTDEV_TIMECODE_UPDATE,                  // Timecode has changed.
        KSEVENT_EXTDEV_OPERATION_MODE_UPDATE,            // Operting mode (VCR,Camera, etc.) has changed.
        KSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,           // Transport state has changed.
        KSEVENT_EXTDEV_NOTIFY_REMOVAL,                   // Device was surprise removal.
        KSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE              // Tape medium is removed or added.
        );


    //{$ENDIF} // XP SP2 and later (chronologically)

    TKSPROPERTY_VIDCAP_CROSSBAR = (
        KSPROPERTY_CROSSBAR_CAPS,                     // R
        KSPROPERTY_CROSSBAR_PININFO,                  // R
        KSPROPERTY_CROSSBAR_CAN_ROUTE,                // R
        KSPROPERTY_CROSSBAR_ROUTE,                    // RW
        KSPROPERTY_CROSSBAR_INPUT_ACTIVE              // R
        );

    TKSPROPERTY_CROSSBAR_CAPS_S = record
        _Property: TKSPROPERTY;
        NumberOfInputs: ULONG;      // the number of audio and video input pins
        NumberOfOutputs: ULONG;     // the number of audio and video output pins
    end;
    PKSPROPERTY_CROSSBAR_CAPS_S = ^TKSPROPERTY_CROSSBAR_CAPS_S;

    TKSPROPERTY_CROSSBAR_PININFO_S = record
        _Property: TKSPROPERTY;
        Direction: TKSPIN_DATAFLOW;     // KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT?
        Index: ULONG;                 // Which pin to return data for?
        PinType: ULONG;               // KS_PhysConn_Video_* or KS_PhysConn_Audio_*
        RelatedPinIndex: ULONG;       // For video pins, this is the related audio pin
        Medium: TKSPIN_MEDIUM;         // Identifies the hardware connection
    end;
    PKSPROPERTY_CROSSBAR_PININFO_S = ^TKSPROPERTY_CROSSBAR_PININFO_S;

    TKSPROPERTY_CROSSBAR_ROUTE_S = record
        _Property: TKSPROPERTY;
        IndexInputPin: ULONG;        // Zero based index of the input pin
        IndexOutputPin: ULONG;       // Zero based index of the output pin
        CanRoute: ULONG;             // returns non-zero on CAN_ROUTE if routing is possible
    end;
    PKSPROPERTY_CROSSBAR_ROUTE_S = ^TKSPROPERTY_CROSSBAR_ROUTE_S;

    TKSPROPERTY_CROSSBAR_ACTIVE_S = record
        _Property: TKSPROPERTY;
        IndexInputPin: ULONG;        // W - Zero based index of the input pin
        Active: ULONG;               // R - returns whether an active signal is present on the given input
    end;
    PKSPROPERTY_CROSSBAR_ACTIVE_S = ^TKSPROPERTY_CROSSBAR_ACTIVE_S;

    TKSEVENT_CROSSBAR = (
        KSEVENT_CROSSBAR_CHANGED);

    // The following IDs should match the AM equivalents
    TKS_PhysicalConnectorType = (
        KS_PhysConn_Video_Tuner = 1,
        KS_PhysConn_Video_Composite,
        KS_PhysConn_Video_SVideo,
        KS_PhysConn_Video_RGB,
        KS_PhysConn_Video_YRYBY,
        KS_PhysConn_Video_SerialDigital,
        KS_PhysConn_Video_ParallelDigital,
        KS_PhysConn_Video_SCSI,
        KS_PhysConn_Video_AUX,
        KS_PhysConn_Video_1394,
        KS_PhysConn_Video_USB,
        KS_PhysConn_Video_VideoDecoder,
        KS_PhysConn_Video_VideoEncoder,
        KS_PhysConn_Video_SCART,

        KS_PhysConn_Audio_Tuner = 4096,
        KS_PhysConn_Audio_Line,
        KS_PhysConn_Audio_Mic,
        KS_PhysConn_Audio_AESDigital,
        KS_PhysConn_Audio_SPDIFDigital,
        KS_PhysConn_Audio_SCSI,
        KS_PhysConn_Audio_AUX,
        KS_PhysConn_Audio_1394,
        KS_PhysConn_Audio_USB,
        KS_PhysConn_Audio_AudioDecoder);


    TKSPROPERTY_VIDCAP_TVAUDIO = (
        KSPROPERTY_TVAUDIO_CAPS,                            // R
        KSPROPERTY_TVAUDIO_MODE,                            // RW
        KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES        // R
        );


    TKSPROPERTY_TVAUDIO_CAPS_S = record
        _Property: TKSPROPERTY;
        Capabilities: ULONG;             // Bitmask of KS_TVAUDIO_MODE_*
        InputMedium: TKSPIN_MEDIUM;
        OutputMedium: TKSPIN_MEDIUM;
    end;
    PKSPROPERTY_TVAUDIO_CAPS_S = ^TKSPROPERTY_TVAUDIO_CAPS_S;

    TKSPROPERTY_TVAUDIO_S = record
        _Property: TKSPROPERTY;
        Mode: ULONG;                     // KS_TVAUDIO_MODE_*
    end;
    PKSPROPERTY_TVAUDIO_S = ^TKSPROPERTY_TVAUDIO_S;

    TKSEVENT_TVAUDIO = (
        KSEVENT_TVAUDIO_CHANGED);

    TKSPROPERTY_VIDCAP_VIDEOCOMPRESSION = (
        KSPROPERTY_VIDEOCOMPRESSION_GETINFO,              // R
        KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,        // RW
        KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME, // RW
        KSPROPERTY_VIDEOCOMPRESSION_QUALITY,              // RW
        KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,    // W
        KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,  // W
        KSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE            // RW
        );

    TKS_CompressionCaps = (
        KS_CompressionCaps_CanQuality = 1,
        KS_CompressionCaps_CanCrunch = 2,
        KS_CompressionCaps_CanKeyFrame = 4,
        KS_CompressionCaps_CanBFrame = 8,
        KS_CompressionCaps_CanWindow = $10);

    //{$if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    TKS_VideoStreamingHints = (
        KS_StreamingHint_FrameInterval = $0100,
        KS_StreamingHint_KeyFrameRate = $0200,
        KS_StreamingHint_PFrameRate = $0400,
        KS_StreamingHint_CompQuality = $0800,
        KS_StreamingHint_CompWindowSize = $1000);

    //{$ENDIF} // XP SP2 and later (chronologically)

    TKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S = record
        _Property: TKSPROPERTY;
        // Note, no VersionString!
        // Note, no DescriptionString!
        StreamIndex: ULONG;             // zero based index of stream
        DefaultKeyFrameRate: LONG;     // Key frame rate
        DefaultPFrameRate: LONG;       // Predeicted frames per Key frame
        DefaultQuality: LONG;          // 0 to 10000
        NumberOfQualitySettings: LONG; // How many discreet quality settings?
        Capabilities: LONG;            // KS_CompressionCaps_*
    end;
    PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S = ^TKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

    TKSPROPERTY_VIDEOCOMPRESSION_S = record
        _Property: TKSPROPERTY;
        StreamIndex: ULONG;             // zero based index of stream
        Value: LONG;                   // value to get or set
    end;
    PKSPROPERTY_VIDEOCOMPRESSION_S = ^TKSPROPERTY_VIDEOCOMPRESSION_S;

    //$if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    TKSPROPERTY_VIDEOCOMPRESSION_S1 = record
        _Property: TKSPROPERTY;
        StreamIndex: ULONG;             // zero based index of stream
        Value: LONG;                   // value to get or set
        Flags: ULONG;
    end;
    PKSPROPERTY_VIDEOCOMPRESSION_S1 = ^TKSPROPERTY_VIDEOCOMPRESSION_S1;

    //{$ENDIF} // XP SP2 and later (chronologically)

    //===========================================================================
    TKSPROPERTY_OVERLAYUPDATE = (
        KSPROPERTY_OVERLAYUPDATE_INTERESTS,
        KSPROPERTY_OVERLAYUPDATE_CLIPLIST = $1,
        KSPROPERTY_OVERLAYUPDATE_PALETTE = $2,
        KSPROPERTY_OVERLAYUPDATE_COLORKEY = $4,
        KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = $8,
        KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = $10,
        KSPROPERTY_OVERLAYUPDATE_COLORREF = $10000000);

    TKSDISPLAYCHANGE = record
        PelsWidth: ULONG;
        PelsHeight: ULONG;
        BitsPerPel: ULONG;
        DeviceID: PWCHAR;
    end;
    PKSDISPLAYCHANGE = ^TKSDISPLAYCHANGE;


    TKSPROPERTY_VIDCAP_VIDEOCONTROL = (
        KSPROPERTY_VIDEOCONTROL_CAPS,               // R
        KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,  // R O
        KSPROPERTY_VIDEOCONTROL_FRAME_RATES,        // R O
        KSPROPERTY_VIDEOCONTROL_MODE                // RWO
        );

    TKS_VideoControlFlags = (
        KS_VideoControlFlag_FlipHorizontal = $0001,
        KS_VideoControlFlag_FlipVertical = $0002,
        KS_Obsolete_VideoControlFlag_ExternalTriggerEnable = $0010,    // ***WARNING *** Flag msimatch with DSHOW.
        KS_Obsolete_VideoControlFlag_Trigger = $0020,  // ***WARNING *** Flag msimatch with DSHOW.
        KS_VideoControlFlag_ExternalTriggerEnable = $0004,
        KS_VideoControlFlag_Trigger = $0008,
        KS_VideoControlFlag_IndependentImagePin = $0040
        //    {$if (NTDDI_VERSION >= NTDDI_WIN8)}
        , KS_VideoControlFlag_StillCapturePreviewFrame = $0080,
        KS_VideoControlFlag_StartPhotoSequenceCapture = $0100,
        KS_VideoControlFlag_StopPhotoSequenceCapture = $0200
        //    {$ENDIF}
        );

    TKSPROPERTY_VIDEOCONTROL_CAPS_S = record
        _Property: TKSPROPERTY;
        StreamIndex: ULONG;
        VideoControlCaps: ULONG;                // KS_VideoControlFlags_*
    end;
    PKSPROPERTY_VIDEOCONTROL_CAPS_S = ^TKSPROPERTY_VIDEOCONTROL_CAPS_S;

    TKSPROPERTY_VIDEOCONTROL_MODE_S = record
        _Property: TKSPROPERTY;
        StreamIndex: ULONG;
        Mode: LONG;                            // KS_VideoControlFlags_*
    end;
    PKSPROPERTY_VIDEOCONTROL_MODE_S = ^TKSPROPERTY_VIDEOCONTROL_MODE_S;

    TKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S = record
        _Property: TKSPROPERTY;
        StreamIndex: ULONG;                     // Index of stream
        RangeIndex: ULONG;                      // Index of range
        Dimensions: TSIZE;                      // Size of image
        CurrentActualFrameRate: LONGLONG;          // Only correct if pin is open
        CurrentMaxAvailableFrameRate: LONGLONG;    // Max Rate temporarily limited on USB or 1394?
    end;
    PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S = ^TKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

    // KSPROPERTY_VIDEOCONTROL_FRAME_RATES returns a list of available frame rates in 100 nS units
    TKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S = record
        _Property: TKSPROPERTY;
        StreamIndex: ULONG;                     // Index of stream
        RangeIndex: ULONG;                      // Index of range
        Dimensions: TSIZE;                      // Size of image
    end;
    PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S = ^TKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

    TKSPROPERTY_VIDCAP_DROPPEDFRAMES = (
        KSPROPERTY_DROPPEDFRAMES_CURRENT            // R
        );

    TKSPROPERTY_DROPPEDFRAMES_CURRENT_S = record
        _Property: TKSPROPERTY;
        PictureNumber: LONGLONG;                   // Current Picture Number
        DropCount: LONGLONG;                       // Count of frames dropped
        AverageFrameSize: ULONG;                // Average size of frames captured
    end;
    PKSPROPERTY_DROPPEDFRAMES_CURRENT_S = ^TKSPROPERTY_DROPPEDFRAMES_CURRENT_S;

    // Both of the above property sets use the same list of properties below

    TKSPROPERTY_VPCONFIG = (
        KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
        KSPROPERTY_VPCONFIG_GETCONNECTINFO,
        KSPROPERTY_VPCONFIG_SETCONNECTINFO,
        KSPROPERTY_VPCONFIG_VPDATAINFO,
        KSPROPERTY_VPCONFIG_MAXPIXELRATE,
        KSPROPERTY_VPCONFIG_INFORMVPINPUT,
        KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
        KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
        KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
        KSPROPERTY_VPCONFIG_INVERTPOLARITY,
        KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,   // E_NOTIMPL for VBI
        KSPROPERTY_VPCONFIG_SCALEFACTOR,            // E_NOTIMPL for VBI
        KSPROPERTY_VPCONFIG_DDRAWHANDLE,
        KSPROPERTY_VPCONFIG_VIDEOPORTID,
        KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
        KSPROPERTY_VPCONFIG_SURFACEPARAMS);

{$if defined(__IVPType__)}

    TKSVPMAXPIXELRATE = record
        Size: TAMVPSIZE;
        MaxPixelsPerSecond: DWORD;
        Reserved: DWORD;
    end;
    PKSVPMAXPIXELRATE = ^TKSVPMAXPIXELRATE;

    TKSVPSIZE_PROP = record
        _Property: TKSPROPERTY;
        Size: TAMVPSIZE;
    end;
    PKSVPSIZE_PROP = TKSVPSIZE_PROP;

    TKSVPSURFACEPARAMS = record
        dwPitch: DWORD;
        dwXOrigin: DWORD;
        dwYOrigin: DWORD;
    end;
    PKSVPSURFACEPARAMS = ^TKSVPSURFACEPARAMS;

{$ELSE}// !defined(__IVPType__)

    //==========================================================================
    // The following definitions must be in sync with DDraw.h in DirectX SDK
    //==========================================================================

    (* The FourCC code is valid. *)

    TDDPIXELFORMAT = record
        dwSize: DWORD;                 // size of structure
        dwFlags: DWORD;                // pixel format flags
        dwFourCC: DWORD;               // (FOURCC code)
        case integer of
            0: (dwRGBBitCount: DWORD;
                case integer of
                    0: (dwRBitMask: DWORD;
                    case integer of
                        0: (dwGBitMask: DWORD;
                        case integer of
                            0: (dwBBitMask: DWORD;
                            case integer of
                                0: (dwRGBAlphaBitMask: DWORD);      // mask for alpha channel
                                1: (dwYUVAlphaBitMask: DWORD);      // mask for alpha channel
                                2: (dwRGBZBitMask: DWORD);          // mask for Z channel
                                3: (dwYUVZBitMask: DWORD);          // mask for Z channel
                            );             // mask for blue bits
                            1: (dwVBitMask: DWORD);             // mask for V bits
                        );             // mask for green bits
                        1: (dwUBitMask: DWORD);             // mask for U bits
                    );             // mask for red bit
                    1: (dwYBitMask: DWORD);             // mask for Y bits
            );          // how many bits per pixel (BD_1,2,4,8,16,24,32)
            1: (dwYUVBitCount: DWORD);          // how many bits per pixel (BD_4,8,16,24,32)
            2: (dwZBufferBitDepth: DWORD);      // how many bits for z buffers (BD_8,16,24,32)
            3: (dwAlphaBitDepth: DWORD);        // how many bits for alpha channels (BD_1,2,4,8)
    end;
    PDDPIXELFORMAT = TDDPIXELFORMAT;

    //{$ENDIF} // _DDPIXELFORMAT_DEFINED

    //{$ENDIF} // !defined(__DDRAW_INCLUDED__)

    //==========================================================================
    // End of DDraw.h header info
    //==========================================================================

    //==========================================================================
    // The following definitions must be in sync with DVP.h in DirectX SDK
    //==========================================================================

    //{$if !defined(__DVP_INCLUDED__)}

    TDDVIDEOPORTCONNECT = record
        dwSize: DWORD;           // size of the DDVIDEOPORTCONNECT structure
        dwPortWidth: DWORD;      // Width of the video port
        guidTypeID: TGUID;       // Description of video port connection
        dwFlags: DWORD;          // Connection flags
        dwReserved1: ULONG_PTR;  // Reserved, set to zero.
    end;
    PDDVIDEOPORTCONNECT = ^TDDVIDEOPORTCONNECT;

    //{$ENDIF} // !defined(__DVP_INCLUDED__)

    //==========================================================================
    // End of DVP.h header info
    //==========================================================================


    //==========================================================================
    // The following definitions must be in sync with VPType.h in AM 2.0 SDK
    //==========================================================================

    // pixel aspect ratios corresponding to a 72$480 NTSC image or a 72$576 image
    // AMPixAspectRatio
    TKS_AMPixAspectRatio = (
        KS_PixAspectRatio_NTSC4x3,
        KS_PixAspectRatio_NTSC16x9,
        KS_PixAspectRatio_PAL4x3,
        KS_PixAspectRatio_PAL16x9);

    // AMVP_SELECTFORMATBY
    TKS_AMVP_SELECTFORMATBY = (
        KS_AMVP_DO_NOT_CARE,
        KS_AMVP_BEST_BANDWIDTH,
        KS_AMVP_INPUT_SAME_AS_OUTPUT);

    // AMVP_MODE
    TKS_AMVP_MODE = (
        KS_AMVP_MODE_WEAVE,
        KS_AMVP_MODE_BOBINTERLEAVED,
        KS_AMVP_MODE_BOBNONINTERLEAVED,
        KS_AMVP_MODE_SKIPEVEN,
        KS_AMVP_MODE_SKIPODD);

    TKS_AMVPDIMINFO = record     // AMVPDIMINFO
        dwFieldWidth: DWORD;            // [out] field width
        dwFieldHeight: DWORD;           // [out] field height
        dwVBIWidth: DWORD;              // [out] VBI data width
        dwVBIHeight: DWORD;             // [out] VBI data height
        rcValidRegion: TRECT;           // [out] valid rect for data cropping
    end;
    PKS_AMVPDIMINFO = ^TKS_AMVPDIMINFO;

    TKS_AMVPDATAINFO = record  // AMVPDATAINFO
        dwSize: DWORD;                 // Size of the struct
        dwMicrosecondsPerField: DWORD; // Time taken by each field
        amvpDimInfo: TKS_AMVPDIMINFO;            // Dimensional Information
        dwPictAspectRatioX: DWORD;     // Pict aspect ratio in X dimn
        dwPictAspectRatioY: DWORD;     // Pict aspect ratio in Y dimn
        bEnableDoubleClock: longbool;     // Videoport should enable double clocking
        bEnableVACT: longbool;            // Videoport should use an external VACT signal
        bDataIsInterlaced: longbool;      // Indicates that the signal is interlaced
        lHalfLinesOdd: LONG;          // number of halflines in the odd field
        bFieldPolarityInverted: longbool; // Device inverts the polarity by default
        dwNumLinesInVREF: DWORD;       // Number of lines of data in VREF
        lHalfLinesEven: LONG;         // number of halflines in the even field
        dwReserved1: DWORD;            // Reserved for future use
    end;
    PKS_AMVPDATAINFO = ^TKS_AMVPDATAINFO;

    TKS_AMVPSIZE = record  // AMVPSIZE
        dwWidth: DWORD;                  // [in] width in pixels
        dwHeight: DWORD;                 // [in] height in pixels
    end;
    PKS_AMVPSIZE = ^TKS_AMVPSIZE;

    //==========================================================================
    // End of VPType.h header info
    //==========================================================================

    TKSVPMAXPIXELRATE = record
        Size: TKS_AMVPSIZE;
        MaxPixelsPerSecond: DWORD;
        Reserved: DWORD;
    end;
    PKSVPMAXPIXELRATE = ^TKSVPMAXPIXELRATE;

    TKSVPSIZE_PROP = record
        _Property: TKSPROPERTY;
        Size: TKS_AMVPSIZE;
    end;
    PKSVPSIZE_PROP = ^TKSVPSIZE_PROP;

    TKSVPSURFACEPARAMS = record
        dwPitch: DWORD;
        dwXOrigin: DWORD;
        dwYOrigin: DWORD;
    end;
    PKSVPSURFACEPARAMS = ^TKSVPSURFACEPARAMS;

    //{$ENDIF} // !defined(__IVPType__)

    TKSEVENT_VPNOTIFY = (
        KSEVENT_VPNOTIFY_FORMATCHANGE);


    TKSEVENT_VIDCAPTOSTI = (
        KSEVENT_VIDCAPTOSTI_EXT_TRIGGER
        , KSEVENT_VIDCAP_AUTO_UPDATE
        , KSEVENT_VIDCAP_SEARCH);

    // Extension Unit Properties

    TKSPROPERTY_EXTENSION_UNIT = (
        KSPROPERTY_EXTENSION_UNIT_INFO,                  // (R)
        KSPROPERTY_EXTENSION_UNIT_CONTROL,               // (RW)
        KSPROPERTY_EXTENSION_UNIT_PASS_THROUGH = $ffff  // (RW)
        );
    PKSPROPERTY_EXTENSION_UNIT = ^TKSPROPERTY_EXTENSION_UNIT;

    TKSEVENT_VPVBINOTIFY = (
        KSEVENT_VPVBINOTIFY_FORMATCHANGE);


    TKSGOP_USERDATA = record
        sc: ULONG;
        reserved1: ULONG;
        cFields: byte;
        l21Data: array[0..2] of char;
    end;
    PKSGOP_USERDATA = ^TKSGOP_USERDATA;


    // -----------------------------------------------------------------------
    // KS_AM_KSPROPSETID_TSRateChange property set definitions for time stamp
    // rate changes.
    // -----------------------------------------------------------------------

    TKS_AM_PROPERTY_TS_RATE_CHANGE = (
        KS_AM_RATE_SimpleRateChange = 1,  // rw, use KS_AM_SimpleRateChange
        KS_AM_RATE_ExactRateChange = 2,   // rw, use KS_AM_ExactRateChange
        KS_AM_RATE_MaxFullDataRate = 3,   // r, use KS_AM_MaxFullDataRate
        KS_AM_RATE_Step = 4               // w, use KS_AM_Step
        );

    TKS_AM_SimpleRateChange = record
        // this is the simplest mechanism to set a time stamp rate change on
        // a filter (simplest for the person setting the rate change, harder
        // for the filter doing the rate change).
        StartTime: TREFERENCE_TIME;  //stream time at which to start this rate
        Rate: LONG;       //new rate * 10000 (decimal)
    end;
    PKS_AM_SimpleRateChange = ^TKS_AM_SimpleRateChange;

    TKS_AM_ExactRateChange = record
        OutputZeroTime: TREFERENCE_TIME; //input TS that maps to zero output TS
        Rate: LONG;       //new rate * 10000 (decimal)
    end;
    PKS_AM_ExactRateChange = ^TKS_AM_ExactRateChange;

    TKS_AM_MaxFullDataRate = LONG; //rate * 10000 (decimal)

    TKS_AM_Step = DWORD; // number of frame to step



    TVIDEOENCODER_BITRATE_MODE = (
        // Bit rate used for encoding is constant
        ConstantBitRate = 0,
        // Bit rate used for encoding is variable with the specified bitrate used
        // as a guaranteed average over a specified window.  The default window
        // size is considered to be 5 minutes.
        VariableBitRateAverage,
        // Bit rate used for encoding is variable with the specified bitrate used
        // as an average with a peak not to exceed the specified peak bitrate over
        // a specified window.  The default window size is considered to be 500ms
        // (classically one GOP).
        VariableBitRatePeak
        );

{$ENDIF}// __ENCODER_API_DEFINES__

    //===========================================================================
    // JACK DESCRIPTION DEFINITIONS
    //===========================================================================

    // define new property id
    TKSPROPERTY_JACK = (
        KSPROPERTY_JACK_DESCRIPTION = 1,
        KSPROPERTY_JACK_DESCRIPTION2,
        KSPROPERTY_JACK_SINK_INFO,
        KSPROPERTY_JACK_CONTAINERID);

    // Enums used in KSPROPERTY_JACK_INFO_STRUCT

    TEPcxConnectionType = (
        eConnTypeUnknown,
        eConnType3Point5mm,
        eConnTypeQuarter,
        eConnTypeAtapiInternal,
        eConnTypeRCA,
        eConnTypeOptical,
        eConnTypeOtherDigital,
        eConnTypeOtherAnalog,
        eConnTypeMultichannelAnalogDIN,
        eConnTypeXlrProfessional,
        eConnTypeRJ11Modem,
        eConnTypeCombination);


    TEPcxGeoLocation = (
        eGeoLocRear = $1,
        eGeoLocFront,
        eGeoLocLeft,
        eGeoLocRight,
        eGeoLocTop,
        eGeoLocBottom,
        eGeoLocRearPanel,
        eGeoLocRiser,
        eGeoLocInsideMobileLid,
        eGeoLocDrivebay,
        eGeoLocHDMI,
        eGeoLocOutsideMobileLid,
        eGeoLocATAPI,
        eGeoLocNotApplicable,
        eGeoLocReserved5 = eGeoLocNotApplicable,
        eGeoLocReserved6,
        EPcxGeoLocation_enum_count);

    TEPcxGenLocation = (
        eGenLocPrimaryBox = 0,
        eGenLocInternal,
        eGenLocSeparate,
        eGenLocOther,
        EPcxGenLocation_enum_count);

    TEPxcPortConnection = (
        ePortConnJack = 0,
        ePortConnIntegratedDevice,
        ePortConnBothIntegratedAndJack,
        ePortConnUnknown);

    // structure for KSPROPERTY_JACK_DESCRIPTION pin property
    TKSJACK_DESCRIPTION = record
        ChannelMapping: DWORD;
        Color: DWORD;   // $00rrggbb; (NOT a COLORREF)
        ConnectionType: TEPcxConnectionType;
        GeoLocation: TEPcxGeoLocation;
        GenLocation: TEPcxGenLocation;
        PortConnection: TEPxcPortConnection;
        IsConnected: longbool;
    end;
    PKSJACK_DESCRIPTION = ^TKSJACK_DESCRIPTION;

    TKSJACK_SINK_CONNECTIONTYPE = (
        KSJACK_SINK_CONNECTIONTYPE_HDMI = 0,            // HDMI
        KSJACK_SINK_CONNECTIONTYPE_DISPLAYPORT         // DisplayPort
        );

    TKSJACK_SINK_INFORMATION = record
        ConnType: TKSJACK_SINK_CONNECTIONTYPE;              // Connection Type
        ManufacturerId: word;                             // Sink manufacturer ID
        ProductId: word;                                  // Sink product ID
        AudioLatency: word;                                    // Sink audio latency
        HDCPCapable: longbool;                                // HDCP Support
        AICapable: longbool;                                  // ACP Packet, ISRC1, and ISRC2 Support
        SinkDescriptionLength: UCHAR;                      // Monitor/Sink name length
        SinkDescription: array [0..MAX_SINK_DESCRIPTION_NAME_LENGTH - 1] of WCHAR;   // Monitor/Sink name
        PortId: LUID;                                     // Video port identifier
    end;
    PKSJACK_SINK_INFORMATION = ^TKSJACK_SINK_INFORMATION;

    TKSJACK_DESCRIPTION2 = record
        DeviceStateInfo: DWORD;
        // Top 16 bits: Report current device state, active, streaming, idle, or hardware not ready
        // Bottom 16 bits: detailed reason to further explain state in top 16 bits
        JackCapabilities: DWORD; // Report jack capabilities such as jack presence detection capability
        // or dynamic format changing capability
    end;
    PKSJACK_DESCRIPTION2 = ^TKSJACK_DESCRIPTION2;

    //{$ENDIF} // (NTDDI_VERSION >= NTDDI_WINXPSP1)

    //===========================================================================

    //===========================================================================
    // HARDWARE AUDIO ENGINE DEFINITIONS
    //===========================================================================

    TKSPROPERTY_AUDIOENGINE = (
        KSPROPERTY_AUDIOENGINE_LFXENABLE = 0,
        KSPROPERTY_AUDIOENGINE_GFXENABLE = 1,
        KSPROPERTY_AUDIOENGINE_MIXFORMAT = 2,
        // constant "3" was skipped on purpose for backward compatibility
        // from the removal of unused KSPROPERTY_AUDIOENGINE_PROCESSINGPERIOD
        KSPROPERTY_AUDIOENGINE_DEVICEFORMAT = 4,
        KSPROPERTY_AUDIOENGINE_SUPPORTEDDEVICEFORMATS = 5,
        KSPROPERTY_AUDIOENGINE_DESCRIPTOR = 6,
        KSPROPERTY_AUDIOENGINE_BUFFER_SIZE_RANGE = 7,
        KSPROPERTY_AUDIOENGINE_LOOPBACK_PROTECTION = 8,
        KSPROPERTY_AUDIOENGINE_VOLUMELEVEL = 9);

    TKSAUDIOENGINE_DESCRIPTOR = record
        nHostPinId: UINT;
        nOffloadPinId: UINT;
        nLoopbackPinId: UINT;
    end;
    PKSAUDIOENGINE_DESCRIPTOR = ^TKSAUDIOENGINE_DESCRIPTOR;

    TKSAUDIOENGINE_BUFFER_SIZE_RANGE = record
        MinBufferBytes: ULONG;
        MaxBufferBytes: ULONG;
    end;
    PKSAUDIOENGINE_BUFFER_SIZE_RANGE = ^TKSAUDIOENGINE_BUFFER_SIZE_RANGE;

    TAUDIO_CURVE_TYPE = (
        AUDIO_CURVE_TYPE_NONE = 0,
        AUDIO_CURVE_TYPE_WINDOWS_FADE = 1);


    TKSAUDIOENGINE_VOLUMELEVEL = record
        TargetVolume: LONG;
        CurveType: TAUDIO_CURVE_TYPE;
        CurveDuration: ULONGLONG;
    end;
    PKSAUDIOENGINE_VOLUMELEVEL = ^TKSAUDIOENGINE_VOLUMELEVEL;

    //===========================================================================
    // AUDIO SIGNAL PROCESSING DEFINITIONS
    //===========================================================================

    TKSPROPERTY_AUDIOSIGNALPROCESSING = (
        KSPROPERTY_AUDIOSIGNALPROCESSING_MODES);


    // Define structure of the KSATTRIBUTE_AUDIOSIGNALPROCESSING_MODE attribute
    TKSATTRIBUTE_AUDIOSIGNALPROCESSING_MODE = record
        AttributeHeader: TKSATTRIBUTE;
        SignalProcessingMode: TGUID;
    end;
    PKSATTRIBUTE_AUDIOSIGNALPROCESSING_MODE = ^TKSATTRIBUTE_AUDIOSIGNALPROCESSING_MODE;

    //{$if (NTDDI_VERSION >= NTDDI_WIN10_RS2)}
    // Interface to get audio modules information.
    TKSPROPERTY_AUDIOMODULE = (
        KSPROPERTY_AUDIOMODULE_DESCRIPTORS = 1,
        KSPROPERTY_AUDIOMODULE_COMMAND = 2,
        KSPROPERTY_AUDIOMODULE_NOTIFICATION_DEVICE_ID = 3);

    TKSAUDIOMODULE_DESCRIPTOR = record
        ClassId: TGUID;
        InstanceId: ULONG;
        VersionMajor: ULONG;
        VersionMinor: ULONG;
        Name: array[0..AUDIOMODULE_MAX_NAME_CCH_SIZE - 1] of WCHAR;
    end;
    PKSAUDIOMODULE_DESCRIPTOR = ^TKSAUDIOMODULE_DESCRIPTOR;

    TKSAUDIOMODULE_PROPERTY = record
        _Property: TKSPROPERTY;
        ClassId: TGUID;
        InstanceId: ULONG;
    end;
    PKSAUDIOMODULE_PROPERTY = ^TKSAUDIOMODULE_PROPERTY;

    // Audio module notification definitions.
    TKSAUDIOMODULE_NOTIFICATION = record
        case integer of
            0: (ProviderId: record
                    DeviceId: TGUID;
                    ClassId: TGUID;
                    InstanceId: ULONG;
                    Reserved: ULONG;
                end;);
            1: (Alignment: LONGLONG);
    end;
    PKSAUDIOMODULE_NOTIFICATION = ^TKSAUDIOMODULE_NOTIFICATION;

//{$ENDIF} // (NTDDI_VERSION >= NTDDI_WIN10_RS2)


implementation



procedure INIT_USBAUDIO_MID(var guid: TGUID; id: USHORT);
begin
    guid.Data1 := $4e1cecd2 + id;
    guid.Data2 := $1679;
    guid.Data3 := $463b;
    guid.Data4[0] := $a7;
    guid.Data4[1] := $2f;
    guid.Data4[2] := $a5;
    guid.Data4[3] := $bf;
    guid.Data4[4] := $64;
    guid.Data4[5] := $c8;
    guid.Data4[6] := $6e;
    guid.Data4[7] := $ba;
end;



function EXTRACT_USBAUDIO_MID(const guid: TGUID): USHORT;
begin
    Result := USHORT(guid.Data1 - $4e1cecd2);
end;



function DEFINE_USBAUDIO_MID_GUID(id: USHORT): TGUID;
begin
    Result.Data1 := $4e1cecd2 + id;
    Result.Data2 := $1679;
    Result.Data3 := $463b;
    Result.Data4[0] := $a7;
    Result.Data4[1] := $2f;
    Result.Data4[2] := $a5;
    Result.Data4[3] := $bf;
    Result.Data4[4] := $64;
    Result.Data4[5] := $c8;
    Result.Data4[6] := $6e;
    Result.Data4[7] := $ba;
end;



function IS_COMPATIBLE_USBAUDIO_MID(guid: TGUID): boolean;
begin
    Result := ((guid.Data1 >= $4e1cecd2) and (guid.Data1 < $4e1cecd2 + $ffff) and
        (guid.Data2 = $1679) and (guid.Data3 = $463b) and (guid.Data4[0] = $a7) and
        (guid.Data4[1] = $2f) and (guid.Data4[2] = $a5) and (guid.Data4[3] = $bf) and
        (guid.Data4[4] = $64) and (guid.Data4[5] = $c8) and (guid.Data4[6] = $6e) and (guid.Data4[7] = $ba));
end;



procedure INIT_USBAUDIO_PID(var guid: TGUID; id: USHORT);
begin
    guid.Data1 := $abcc5a5e + id;
    guid.Data2 := $c263;
    guid.Data3 := $463b;
    guid.Data4[0] := $a7;
    guid.Data4[1] := $2f;
    guid.Data4[2] := $a5;
    guid.Data4[3] := $bf;
    guid.Data4[4] := $64;
    guid.Data4[5] := $c8;
    guid.Data4[6] := $6e;
    guid.Data4[7] := $ba;
end;



function EXTRACT_USBAUDIO_PID(guid: TGUID): USHORT;
begin
    Result := USHORT(guid.Data1 - $abcc5a5e);
end;



function DEFINE_USBAUDIO_PID_GUID(id: USHORT): TGUID;
begin
    Result.Data1 := $abcc5a5e + id;
    Result.Data2 := $c263;
    Result.Data3 := $463b;
    Result.Data4[0] := $a7;
    Result.Data4[1] := $2f;
    Result.Data4[2] := $a5;
    Result.Data4[3] := $bf;
    Result.Data4[4] := $64;
    Result.Data4[5] := $c8;
    Result.Data4[6] := $6e;
    Result.Data4[7] := $ba;
end;



function IS_COMPATIBLE_USBAUDIO_PID(guid: TGUID): boolean;
begin
    Result := ((guid.Data1 >= $abcc5a5e) and (guid.Data1 < $abcc5a5e + $ffff) and
        (guid.Data2 = $c263) and (guid.Data3 = $463b) and (guid.Data4[0] = $a7) and
        (guid.Data4[1] = $2f) and (guid.Data4[2] = $a5) and (guid.Data4[3] = $bf) and
        (guid.Data4[4] = $64) and (guid.Data4[5] = $c8) and (guid.Data4[6] = $6e) and (guid.Data4[7] = $ba));
end;

end.
